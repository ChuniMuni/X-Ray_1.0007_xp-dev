-- файл из мода "Народной солянки 2009" от 14.06. Адаптирован для мода 'Метки с хабаром 2.1.4' 06.07.2009
-- Адаптирован для Менеджера оружия. Rulix aka Bak от 2.07.09
-- Адатировал: Idler.

local table_sort = table.sort
local table_insert = table.insert
local table_remove = table.remove
local math_random = math.random
local math_floor = math.floor
local math_abs = math.abs
local math_ceil = math.ceil
local string_sub = string.sub

local sim

off_npcs = {}
items = {}
relation_matrix = {}
tables_ready = false
local sell_table = {}
local always_keep_item = {}
local wpn_ammo_w = {}	-- wpn_ammo_w[ствол][патроны]

local wpn_fp = {}
-- Пора апдейт делать
local bFlag = false
-- Номер последнего отработанного обьекта
local iCounter = 0
-- Время последнего глобального апдейта
local iTime = -1
-- Как часто делать апдейты, игровые минуты
local iFreq = 120
local initialized = false   -- флаг инициализации

local monster_params = {}

local maps = {
	"l01_escape",
	"l02_garbage",
	"l03_agroprom",
--	"l03u_agr_underground",
	"l04_darkvalley",
--	"l04u_labx18",
	"l05_bar",
	"l06_rostok",
	"l07_military",
	"l08_yantar"--,
	--"l08u_brainlab",
	--"l10_radar",
	--"l10u_bunker",
	--"l11_pripyat",
	--"l12_stancia",
	--"l12_stancia_2",
	--"l12u_control_monolith",
	--"l12u_sarcofag"
}

-- Таблица запрета по:
-- уникальные имена, секции, иды и стори_иды объектов
protected = {
	names = {},
	sections = {
	["rx_inventory_box"] = true,
	["yad"] = true,
	["rx_attach_bandage"] = true
	},
	ids = {},
	story_ids = {
	[5008] = true,
	[5013] = true,
	[5014] = true,
	[5041] = true,
	[5065] = true,
	[5084] = true,
	[5104] = true,
	[5205] = true,
	[5222] = true,
	[5226] = true,
	[5237] = true,
	[5238] = true,
	[5243] = true,
	[5244] = true,
	[5245] = true,
	[5246] = true,
	[5247] = true,
	[5248] = true,
	[5249] = true,
	[5250] = true,
	[5254] = true,
	[5255] = true,
	[5408] = true,
	[5413] = true,
	[5428] = true,
	[5433] = true,
	[5434] = true,
	[5444] = true,
	[5446] = true,
	[5470] = true,
	[5471] = true,
	[5472] = true,
	[5473] = true,
	[5474] = true,
	[573] = true
	}
}

local smart_filters = {
	["esc_bridge"] = true,
	["esc_blokpost"] = true
}

local is_good_stalker = {
	["stalker"] = true,
	["ecolog"] = true,
	["green"] = true,
	["nebo"] = true,
	["bandos"] = true,
	["voin"] = true,
	["dolg"] = true,
	["freedom"] = true
}

local rel_enemy, rel_friend

--радиус "обзора"
local look_radius = 100
--интенсивность поиска (количество отрабатываемых неписей)
local search_intensivity = 30
-- продолжительность боев
local max_rounds = 8
-- При каком уровне здоровья НПС считается раненым
local health_wound = 0.20
local health_wound_set = 0.02
-- Эталон firepower\distance при distance = 1 который снимет 100% health
local base_fp = 1400
-- Коэффициент для расстояния
local dist_coeff = 8
-- Вещи дешевле продает торговцам
local sell_limit = 3000
-- Рейтинг за убийство. При убийстве более слабого - 0.5 * rate_kill_base, более сильного - 2 * rate_kill_base
local rate_kill_base = 100
local rate_art_found = 100
local to_actor = 150
local look_radius_box = 25*25
local look_radius_art = 50*50
local look_radius_wpn = 30*30
local look_radius_stalker = 70*70
local look_radius_monster = 50*50
local allow_box = true

wpn_priors_by_comms = {	-- community[section] == slot или 1
	military = {
		["wpn_ak74"]	= 3,
		["wpn_ak74u"]	= 3,
		["wpn_abakan"]	= 3,
		["wpn_pm"]	= 2,
		["wpn_val"]	= 3,
		["wpn_walther"]	= 2,
		["wpn_vintorez"]= 3,
		["wpn_groza"]	= 3}
	}

item_types = {
--	["harmonica_a"]			= "music",
--	["guitar_a"]			= "music",
--	["sigaret"]			= "smoke",
--	["cigara"]			= "smoke",
	["mutant_flesh_eye"]         = "mpart",
	["mutant_boar_leg"]          = "mpart",
	["mutant_dog_tail"]          = "mpart",
	["mutant_psevdodog_tail"]    = "mpart",
	["mutant_krovosos_jaw"]      = "mpart",
	["mutant_burer_hand"]        = "mpart",
	["mutant_zombie_hand"]       = "mpart",
	["mutant_snork_leg"]         = "mpart",
	["mutant_spleen_rat"]        = "mpart",
	["mutant_face_tushkano"]     = "mpart",
	["mutant_fracture_hand"]     = "mpart",
	["mutant_hand_kontroler"]    = "mpart",
	["mutant_poltergeist_glas"]  = "mpart",
	["mutant_psevdogigant_hand"] = "mpart",
	["mutant_tail_cat"]          = "mpart",
	["mutant_chimera_kogot"]     = "mpart",
	["mutant_zombie_teeth"]      = "mpart",
	["mutant_tarakan_part"]      = "mpart",
	["part_digitis_biblio"]      = "mpart"
	}


function init()
	if (initialized == false) then
		build_tables()
		iTime = (amk.game_minutes() - iFreq) + 3
		initialized = true
	end
end

function update()
	if (bFlag == false and iTime ~= -1) then
		if (amk.game_minutes() - iTime > iFreq) then
			bFlag = true			
			off_npcs={}	
			items={}
			iCounter = 1
		end
	end
	if (bFlag == true) then
		if (iCounter >= 65535) then
			bFlag = false
			iTime = amk.game_minutes()
			iCounter = 1
		else
			local obj
			obj = alife():object(iCounter)
			add_fresh_meat(obj)
			iCounter = iCounter + 1
		end
	end
end

--on_death - не убиваем!
--on_hit - не обрабатываем!
local ignored_sections = {
	["buddy_bibliotekar"] = true,
	["buddy_bloodsucker"] = true,
	["buddy_dog"] = true,
	["mouses"] = true,
	["buddy_pseudodog"] = true,
	["buddy_psevdopup"] = true
}

function add_fresh_meat(obj)
	if obj and obj.m_game_vertex_id and game_graph():valid_vertex_id(obj.m_game_vertex_id)
		and db.actor and db.actor:id() ~= obj.id and not protected_items.doNotTouchItemEquipment(obj)
		and not ignored_sections[obj:section_name()]
	then
		local map = alife():level_name(game_graph():vertex(obj.m_game_vertex_id):level_id())
		if not off_npcs[map] then
			off_npcs[map] = {monsters={}, stalkers={}, weapons={}, artefacts={}, inv_boxes={}}
		end
		if IAmAMonster[obj:clsid()] and obj.alive and obj:alive() and obj.health and obj:health()>0 and obj.m_story_id == 4294967296 then
				local flags = get_flags(obj.id)
				if flags == 0 or flags == 2 then --Уберем тех, у кого on_hit есть.
					table_insert(off_npcs[map].monsters, {id = obj.id, name = obj:name()})
				end
		elseif IAmAStalker[obj:clsid()] and obj.alive and obj:alive() and obj.health and obj:health()>0 and obj.m_story_id == 4294967296 then
				local flags = get_flags(obj.id)
				if flags == 0 or flags == 2 then --Уберем тех, у кого on_hit есть.
					if obj:community() ~= "zombied" then
						table_insert(off_npcs[map].stalkers, {id = obj.id, name = obj:name()})
					else
						table_insert(off_npcs[map].monsters, {id = obj.id, name = obj:name()})
					end
				end
		elseif IAmAWeapon[obj:clsid()] then
			if obj.m_story_id == 4294967296 then
				if obj.parent_id then
					local p_obj = alife():object(obj.parent_id)
					if p_obj then
						if p_obj.m_game_vertex_id and game_graph():valid_vertex_id(p_obj.m_game_vertex_id) then
							if p_obj:clsid() == clsid.inventory_box then
								-- НПС "не видят" этого
								map = ""
							else
								local p_map = alife():level_name(game_graph():vertex(p_obj.m_game_vertex_id):level_id())
								if p_map ~= map then
									if not off_npcs[p_map] then
										off_npcs[p_map] = {monsters={}, stalkers={}, weapons={}, artefacts={}, inv_boxes={}}
									end
									map = p_map
								end
							end
						else
							map = ""
						end
					end
				end
				if map ~= "" then
					table_insert(off_npcs[map].weapons, {id=obj.id, name = obj:name()})
				end
			end
		elseif string_sub(obj:section_name(), 1, 3) == "af_" then
			if obj.parent_id then
				local p_obj = alife():object(obj.parent_id)
				if p_obj then
					if p_obj.m_game_vertex_id and game_graph():valid_vertex_id(p_obj.m_game_vertex_id) then
						if p_obj:clsid() == clsid.inventory_box then
							-- НПС "не видят" этого
							map = ""
						else
							local p_map = alife():level_name(game_graph():vertex(p_obj.m_game_vertex_id):level_id())
							if p_map ~= map then
								if not off_npcs[p_map] then
									off_npcs[p_map] = {monsters={}, stalkers={}, weapons={}, artefacts={}, inv_boxes={}}
								end
								map = p_map
							end
						end
					else
						map = ""
					end
				end
			end
			if map ~= "" then
				table_insert(off_npcs[map].artefacts, {id = obj.id, name = obj:name()})
			end
			--elseif (obj:section_name()=="inventory_box" and box_is_protected(obj)==false) then
		elseif obj:clsid() == clsid.inventory_box and not box_is_protected(obj) then
			table_insert(off_npcs[map].inv_boxes, {id = obj.id, name = obj:name()})
		end
		if obj.parent_id and obj.m_story_id == 4294967296 and not IAmAMonster[obj:clsid()] and not IAmAStalker[obj:clsid()] then
			local zz = alife():object(obj.parent_id)
			if zz and zz:section_name() ~= "rx_inventory_box" then
				if not items[obj.parent_id] then
					items[obj.parent_id] = {}
				end
				table_insert(items[obj.parent_id], {id = obj.id, name=obj:name()})
				gps_habar.insert_item(obj.parent_id, obj) -- Idler++-- корректируем хабар в помеченных тайниках
			end
		end
	end
end

--строим таблицу неписей, монстров и оружия
function build_tables()
	-- Почистим таблицу

	rel_enemy, rel_friend = getIniValueFloatSimple("game_relations", "goodwill_enemy", -1000), getIniValueFloatSimple("game_relations", "goodwill_friend", 1000)
	local s_comm_list = getIniValueStringSimple("game_relations", "communities", "")
	local comm_list = {}
	local s_value = Parse_StrToTbl(s_comm_list, ",")
	for a=1, #s_value, 2 do
		local s_comm = s_value[a]
		table_insert(comm_list, s_comm)
	end
  
	local tmp={}
	local result, id, value = nil, nil, nil
	local n = iniLinesCountSimple("communities_relations")
	for a=0,n-1 do
		result, id, value = getIniLineSimple("communities_relations",a,"","")
		if id~=nil and trim(id)~="" and trim(id)~=nil then
			relation_matrix[trim(id)]={}
			table_insert(tmp, trim(id))
		end
	end
	
	for a=1,#tmp do
		-- local value = utils.cfg_get_string(system_ini(), "communities_relations", tmp[a], nil, false, "", "")
		local value = getIniValueStringSimple("communities_relations", tmp[a], "")
		local idx = tmp[a]
		local m_value = Parse_StrToTbl(value, ",")
		for i=1, #m_value do
			local idx2 = comm_list[i]
			local v = m_value[i]
			if relation_matrix[idx] and idx2~=nil and v ~= nil then
				relation_matrix[idx][idx2]=tonumber(trim(v))
			end
		end
	end

	iniFileName = "misc\\death_generic.ltx"
	local death_ini = g_ini_file(iniFileName)
 	--' Предметы, которые нельзя продавать (квестовые например)
	always_keep_item = {}
    local n = death_ini:line_count("keep_items")
	for i=0,n-1 do
		result, id, value	= death_ini:r_line("keep_items",i,"","")
        if value == "true" then
            always_keep_item[id] = true
        end
    end
	
	tables_ready = true
end

function update_npc_tables()
	off_npcs = {}
	local obj
	local sim = alife()
	for a = 1, 65534 do
		obj = sim:object(a)
		if obj then
			add_fresh_meat(obj)
		end
	end
	bFlag = false
	iTime = amk.game_minutes()
	iCounter = 1
end


function update_tables(level)
	off_npcs[level]={monsters={},stalkers={},weapons={},artefacts={}, inv_boxes={}}
	local obj, p_obj
	local ggraph = game_graph()
	local sim = alife()
	for a=1,65534 do
		obj = sim:object(a)
		if obj then
			if ggraph:valid_vertex_id(obj.m_game_vertex_id) and sim:level_name(ggraph:vertex(obj.m_game_vertex_id):level_id()) == level then
			add_fresh_meat(obj)
			elseif obj.parent_id then
				p_obj = sim:object(obj.parent_id)
				if p_obj and ggraph:valid_vertex_id(p_obj.m_game_vertex_id)	and sim:level_name(ggraph:vertex(p_obj.m_game_vertex_id):level_id()) == level then
					add_fresh_meat(obj)
				end
			end
		end
	end	
end

--генерируем оффлайн события
function offline_alife()
	local lname = maps[math_random(#maps)]
--	update_tables(lname)
	local st = 0
	amk.oau_reason="cn offline_alife chp1"
	if off_npcs[lname] then st = #off_npcs[lname].stalkers end
	if st>0 then
	amk.oau_reason="cn offline_alife chp2"
		for search = 1,search_intensivity do
	amk.oau_reason="cn offline_alife chp3"
			local rnd = math_random(st)
	amk.oau_reason="cn offline_alife chp4"
			if off_npcs[lname].stalkers[rnd] then 
	amk.oau_reason="cn offline_alife chp5"
				local victim = alife():object(off_npcs[lname].stalkers[rnd].id)
	amk.oau_reason="cn offline_alife chp6"
				if victim and not victim.online and victim.health and victim.can_switch_online and victim:health()>0 and victim:can_switch_online() and victim:name() == off_npcs[lname].stalkers[rnd].name then
	amk.oau_reason="cn offline_alife chp7 "..tostring(victim and victim:name())
					local vdata = collect_info(victim,lname)
	amk.oau_reason="cn offline_alife chp8 "..tostring(victim and victim:name())
					if #vdata.enemies>0 then
					--есть вражина - воюем нах!
	amk.oau_reason="cn offline_alife chp9 "..tostring(victim and victim:name())
						on_enemies_found(victim, vdata, lname, rnd)
						break	--прерываем цикл - событие отработано
					elseif #vdata.monsters>0 then
					--есть монстрятина - видели, слышали, убили, сдохли...
	amk.oau_reason="cn offline_alife chp10 "..tostring(victim and victim:name())
						on_monsters_found(victim, vdata, lname, rnd)
						break	--прерываем цикл - событие отработано
					elseif #vdata.corpses.stalkers>0 then
					--есть труп сталкера
	amk.oau_reason="cn offline_alife chp11 "..tostring(victim and victim:name())
						on_npc_corpses_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif #vdata.corpses.monsters>0 then
					--есть труп монстра
	amk.oau_reason="cn offline_alife chp12 "..tostring(victim and victim:name())
						on_monster_corpses_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif #vdata.weapons.seen>0 then
					--есть бесхозное оружие
	amk.oau_reason="cn offline_alife chp13 "..tostring(victim and victim:name())
						on_weapons_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif #vdata.artefacts>0 then
					--есть арты
	amk.oau_reason="cn offline_alife chp14 "..tostring(victim and victim:name())
						on_artifacts_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif #vdata.inv_boxes>0 then
					--есть контейнеры. Надо обыскать.
	amk.oau_reason="cn offline_alife chp18 "..tostring(victim and victim:name())
--						on_inv_boxes_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif items[victim.id] and #items[victim.id] > 0 then
					--попробуем продать всякого
	amk.oau_reason="cn offline_alife chp15 "..tostring(victim and victim:name())
						break
					else
					end
				end
			end
		end
	end
	amk.oau_reason="cn offline_alife end"
end

--собираем инфу о неписе
function collect_info(victim,map)
	local vdata = {}
	vdata.rank = victim:rank() --ранг
	vdata.health = victim:health()  --хелсы
	vdata.community = victim:community()  --группировка
	
	--пытаемся определить пушку
	local wp = #off_npcs[map].weapons
	--условная огневая мощь
	vdata.fire_power = 0
	
	local sim = alife()
	vdata.weapons={own={},seen={}}
	-- если есть пушки в карманах, выбираем лучшую (по условной мощности)
	if wp>0 then
		for w=1,wp do
			if off_npcs[map].weapons[w] then
				local www = sim:object(off_npcs[map].weapons[w].id)
				if www and www:name()==off_npcs[map].weapons[w].name then
					if www.parent_id == victim.id then
						table_insert(vdata.weapons.own, {id = www.id, name = www:name()})
						local fp = get_weapon_firepower(www)
						if vdata.fire_power<fp then vdata.fire_power=fp end
					elseif www:can_switch_online() and victim.position:distance_to_sqr(www.position)<look_radius_box and sobj_is_far(www, to_actor) then
						--if www.parent_id==nil or www.parent_id==65535 or (sim:object(www.parent_id) and sim:object(www.parent_id):section_name()=="inventory_box") then
						if www.parent_id==nil or www.parent_id==65535 or (sim:object(www.parent_id) and sim:object(www.parent_id):clsid() == clsid.inventory_box) then
							table_insert(vdata.weapons.seen, {id = www.id, name = www:name()})
						end
					end
				end
			end
		end
	end
	
	--составляем списки друзей и врагов в зоне "видимости"
	-- Для тех, у кого смарт в фильтрах - не собираем врагов
	-- Для остальных - не учитываем врагов из смартов
	local npc_peaceful = npc_smart_is_peaceful(victim)
	
	vdata.friends={}
	vdata.enemies={}
	vdata.corpses={monsters={},stalkers={}}
	if #off_npcs[map].stalkers>0 then
		for a=1,#off_npcs[map].stalkers do
			if off_npcs[map].stalkers[a] then
				local opponent = sim:object(off_npcs[map].stalkers[a].id)
				if opponent and opponent.id~=victim.id and opponent.health and opponent.can_switch_online and opponent:can_switch_online() and opponent:name() == off_npcs[map].stalkers[a].name  then
					if victim.position:distance_to_sqr(opponent.position)<look_radius_stalker then -- DC --
						if opponent:health()>0 then
							local rel = relation_check(victim,opponent)
							if rel>=rel_friend then
								table_insert(vdata.friends, {id = opponent.id, name = opponent:name(), stalker_number = a, stalker_map = map})
							elseif rel<=rel_enemy then
								if npc_peaceful == false and npc_smart_is_peaceful(opponent) == false then
									table_insert(vdata.enemies, {id = opponent.id, name = opponent:name(), stalker_number = a, stalker_map = map})
								end
							end
						else
							if (sobj_is_far(opponent, to_actor)) then
								table_insert(vdata.corpses.stalkers, {id = opponent.id, name = opponent:name()})
							end
						end
					end
				end
			end
		end
	end
	
	--составляем список монстряков в зоне "видимости"
	vdata.monsters={}
	if off_npcs[map].monsters then
		if #off_npcs[map].monsters>0 then
			for a=1,#off_npcs[map].monsters do
				if off_npcs[map].monsters[a] then
					local monster = sim:object(off_npcs[map].monsters[a].id)
					if monster and monster.health and monster.can_switch_online and monster:can_switch_online() and monster:name() == off_npcs[map].monsters[a].name and victim.position:distance_to_sqr(monster.position)<look_radius_monster then -- DC --
						if monster:health()>0 then
							table_insert(vdata.monsters, {id = monster.id, name = monster:name(), monster_number = a, monster_map = map})
						else
							if (sobj_is_far(monster, to_actor)) then
								table_insert(vdata.corpses.monsters, {id = monster.id, name = monster:name()})
							end
						end
					end
				end
			end
		end
	end
	
	--составляем список артов в зоне "видимости"
	vdata.artefacts={}
	if off_npcs[map].artefacts then
		if #off_npcs[map].artefacts>0 then
			for a=1,#off_npcs[map].artefacts do
				if off_npcs[map].artefacts[a] then
					local artefact = sim:object(off_npcs[map].artefacts[a].id)
					if (artefact and artefact.can_switch_online and artefact:can_switch_online() and artefact:name() == off_npcs[map].artefacts[a].name and victim.position:distance_to_sqr(artefact.position)<look_radius_art and sobj_is_far(artefact, to_actor)) then -- DC --
						--if artefact.parent_id==nil or artefact.parent_id==65535 or (sim:object(artefact.parent_id) and (sim:object(artefact.parent_id):section_name()=="inventory_box" or (sim:object(artefact.parent_id):clsid()>172 and sim:object(artefact.parent_id):clsid()<180))) then
						--if artefact.parent_id==nil or artefact.parent_id==65535 or (sim:object(artefact.parent_id) and (sim:object(artefact.parent_id):clsid() == clsid.inventory_box or (sim:object(artefact.parent_id):clsid()>172 and sim:object(artefact.parent_id):clsid()<180))) then
						if artefact.parent_id==nil or artefact.parent_id==65535 or (sim:object(artefact.parent_id) and (sim:object(artefact.parent_id):clsid() == clsid.inventory_box or amk_anoms.is_anomaly(sim:object(artefact.parent_id):clsid()))) then
							table_insert(vdata.artefacts, {id = artefact.id, name = artefact:name()})
						end
					end
				end
			end
		end
	end
	
	--составляем список контейнеров в зоне "видимости"
	vdata.inv_boxes={}
	if off_npcs[map].inv_boxes then
		if #off_npcs[map].inv_boxes>0 then
			for a=1,#off_npcs[map].inv_boxes do
				if off_npcs[map].inv_boxes[a] then
					local inv_box = sim:object(off_npcs[map].inv_boxes[a].id)
					if (inv_box and inv_box.can_switch_online and inv_box:can_switch_online() and inv_box:name() == off_npcs[map].inv_boxes[a].name and victim.position:distance_to_sqr(inv_box.position)<=look_radius_box and sobj_is_far(inv_box, to_actor)) then
						local zdist = victim.position:distance_to(inv_box.position)/100
						if math_random() > zdist then
							if inv_box.parent_id==nil or inv_box.parent_id==65535 then
								table_insert(vdata.inv_boxes, {id = inv_box.id, name = inv_box:name()})
							end
						end
					end
				end
			end
		end
	end

	return vdata
end

-- получаем отношение группировки к неписю, в оффлайне фактически равно личным отношениям неписей
function relation_check(victim,opponent)
	if relation_matrix[opponent:community()] and relation_matrix[opponent:community()][victim:community()] then
		return relation_matrix[opponent:community()][victim:community()]
	else
		return 0
	end
end

-- Вокруг враги! Что же делать..
function on_enemies_found(victim, vdata, victim_map, victim_number)
	if (victim == nil or vdata == nil) then return end
	local obj, v_obj
	local team_A = {}
	local team_B = {}
	-- Собираем weapons
	-- Учитываем rank, weapon, distance...
	local wpn = get_npc_weapon(victim)
	local rank = victim:rank()
	local health = victim:health()
	local firepower = get_weapon_firepower(wpn)
	local player = {player = victim, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(victim.id), stalker_number = victim_number, stalker_map = victim_map}
	table_insert(team_A, player)
	if (vdata.friends and #vdata.friends > 0) then
		for i=1, #vdata.friends do
			v_obj = vdata.friends[i]
			if v_obj then
				obj = alife():object(v_obj.id)
				if (obj and obj:name()==v_obj.name) then
					wpn = get_npc_weapon(obj)
					rank = obj:rank()
					health = obj:health()
					firepower = get_weapon_firepower(wpn)
					player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id), stalker_number = v_obj.stalker_number, stalker_map = v_obj.stalker_map}
					table_insert(team_A, player)
				end
			end
		end
	end
	for i=1, #vdata.enemies do
		v_obj = vdata.enemies[i]
		obj = alife():object(v_obj.id)
		if (obj and obj:name() == v_obj.name) then
			wpn = get_npc_weapon(obj)
			if (wpn == nil) then
				list_npc_items(obj)
			end
			rank = obj:rank()
			health = obj:health()
			firepower = get_weapon_firepower(wpn)
			player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id), stalker_number = v_obj.stalker_number, stalker_map = v_obj.stalker_map}
			table_insert(team_B, player)
		end
	end
	local distances = {}
	for a=1, #team_A do
		local from = team_A[a].player
		distances[from.id] = {}
		for b=1, #team_B do
			local to = team_B[b].player
			distances[to.id] = {}
			if (from and to and from.id and to.id) then
				local dist = math_floor(from.position:distance_to(to.position))
				local fp_A = math_floor(team_A[a].firepower / (dist / dist_coeff))
				local fp_B = math_floor(team_B[b].firepower / (dist / dist_coeff))
				local item = {distance = dist, fpA = fp_A, fpB = fp_B}
				distances[from.id][to.id] = {distance = dist, fp = fp_A}
				distances[to.id][from.id] = {distance = dist, fp = fp_B}
			end
		end
	end
	-- Берем тех, у кого самый высокий rank и мин. distance
	table_sort(team_A, function(a,b) return a.rank > b.rank end)
	table_sort(team_B, function(a,b) return a.rank > b.rank end)
	-- 10 раундов
	local size_A = #team_A
	local size_B = #team_B
	local died_A = 0
	local died_B = 0
	for i=1, max_rounds do
		if (#team_A >0 and #team_B > 0) then
			local index = #team_A
			local attacker
			local defender 
			local attack_info 
			local rank_hit_chance
			local distance_hit_chance
			local hit_chance			
			if (#team_B > index) then index = #team_B end
			for j = 1, index do
				attacker = team_A[j]
				defender = team_B[math_random(#team_B)]
				if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
					attack_info = distances[attacker.player.id][defender.player.id]
					-- Попал или нет? Зависит от: расстояния, рангов
					-- master to novice - 30% max
					-- 100 метров - 33% 10 метров - 100% 1 метр - 115% Каждый метр - минус 1.5% попасть.
					rank_hit_chance = math_floor((attacker.rank - defender.rank) / 50)
					distance_hit_chance = 100 - math_floor((attack_info.distance) / 1.5)					
					hit_chance = distance_hit_chance + rank_hit_chance
					if ((math_random() * 100) < hit_chance) then
						-- Попал таки, гад. Посмотрим, как сильно.
						if (attack_info.fp >= base_fp) then
							-- Все, убил.
							defender.health = 0
						else
							defender.health = defender.health - (attack_info.fp / base_fp)
							if (defender.health < 0 ) then defender.health = 0 end							
						end
						if (defender.health <= 0) then
							if (defender.flags >= 2) then
								defender.health = health_wound
							else
								-- Если сталкер - дадим опыт.
								if attacker.player and IAmAStalker[attacker.player:clsid()] and attacker.player.community then
									local m_comm  = attacker.player:community()
									if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
										-- Будет теперь опытным.
										local coeff = 1
										if (defender.rank < attacker.rank) then coeff = 0.5 end
										if (defender.rank > attacker.rank) then coeff = 2 end
										attacker.player:set_rank(attacker.player:rank() + math_floor(rate_kill_base * coeff))
									end
								end
								news_main.on_offline_death(defender.player, attacker.player, attacker.weapon)
								-- Заберем вещички с трупа
								local itA, v_itA
								local l_objA
								if (items[defender.player.id] and #items[defender.player.id] > 0) then
									for a=1,#items[defender.player.id] do
										v_itA = items[defender.player.id][a]
										if (v_itA) then
											itA = alife():object(v_itA.id)
											if (itA and itA:name()==v_itA.name and itA.parent_id == defender.player.id) then
												l_objA = pick_item(attacker.player, itA)
											else
												if(itA) then
													local mm = itA.parent_id
													if mm == nil then mm = "nil" end
												end
											end	
										end
									end
								end
							end
						end
					end
				end
				-- team_B - защищается
				if (team_B[j] ~= nil) then
					attacker = team_B[j]
					defender = team_A[math_random(#team_A)]
					if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
						attack_info = distances[attacker.player.id][defender.player.id]
						-- Попал или нет? Зависит от: расстояния, рангов
						-- master to novice - 30% max
						-- 100 метров - 33% 10 метров - 100% 1 метр - 115% Каждый метр - минус 1.5% попасть.
						rank_hit_chance = math_floor((attacker.rank - defender.rank) / 50)
						distance_hit_chance = 100 - math_floor((attack_info.distance) / 1.5)					
						hit_chance = distance_hit_chance + rank_hit_chance
						if math_random() * 100 < hit_chance then
							-- Попал таки, гад. Посмотрим, как сильно.
							if attack_info.fp >= base_fp then
								-- Все, убил.
								defender.health = 0
							else
								defender.health = defender.health - (attack_info.fp / base_fp)
								if (defender.health < 0 ) then defender.health = 0 end
							end
							if (defender.health <= 0) then
								if (defender.flags >= 2) then
									defender.health = health_wound
								else								
									-- Если сталкер - дадим опыт.
									if attacker.player and IAmAStalker[attacker.player:clsid()] and attacker.player.community then
										local m_comm  = attacker.player:community()
										if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
											-- Будет теперь опытным.
											local coeff = 1
											if (defender.rank < attacker.rank) then coeff = 0.5 end
											if (defender.rank > attacker.rank) then coeff = 2 end
											attacker.player:set_rank(attacker.player:rank() + math_floor(rate_kill_base * coeff))							
										end
									end
									news_main.on_offline_death(defender.player, attacker.player, attacker.weapon)
									-- Заберем вещички с трупа
									local itB, v_itB
									local l_objB
									if (items[defender.player.id] and #items[defender.player.id] > 0) then
										for a=1,#items[defender.player.id] do
											v_itB = items[defender.player.id][a]
											if (v_itB) then
												itB = alife():object(v_itB.id)
												if (itB and itB:name() == v_itB.name and itB.parent_id == defender.player.id) then
													l_objB = pick_item(attacker.player, itB)
												else
													if(itB) then
														local mm = itB.parent_id
														if mm == nil then mm = "nil" end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		else
			-- Теперь и событие можно сформировать для новостей
			break
		end
		-- Почистим таблицы от трупов
		for kk, vv in pairs(team_A) do
			if (vv.health <=0) then
				set_npc_health(vv.player, 0)
				table_remove(team_A, kk)
				table_remove(off_npcs[vv.stalker_map].stalkers, vv.stalker_number)
				died_A = died_A + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				set_npc_health(vv.player, health_wound_set)
				news_main.on_offline_wound(vv.player)
				table_remove(team_A, kk)
				table_remove(off_npcs[vv.stalker_map].stalkers, vv.stalker_number)
			end
		end
		for kk, vv in pairs(team_B) do
			if (vv.health <=0) then
				set_npc_health(vv.player, 0)
				table_remove(team_B, kk)
				table_remove(off_npcs[vv.stalker_map].stalkers, vv.stalker_number)
				died_B = died_B + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				set_npc_health(vv.player, health_wound_set)
				news_main.on_offline_wound(vv.player)
				table_remove(team_B, kk)
				table_remove(off_npcs[vv.stalker_map].stalkers, vv.stalker_number)
			end
		end		
	end
end

-- Вокруг монстры! Что же делать..
function on_monsters_found(victim, vdata, victim_map, victim_number)
  amk.oau_reason="on_monsters_found begin"
	if (victim == nil or vdata == nil) then return end
	-- Собираем комманды.
	local obj, v_obj
	local team_A = {}
	local team_B = {}
	local wpn = get_npc_weapon(victim)
	local rank = victim:rank()
	local health = victim:health()
	local firepower = get_weapon_firepower(wpn)
	local player = {player = victim, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(victim.id), stalker_number = victim_number, stalker_map = victim_map}
	table_insert(team_A, player)
  amk.oau_reason="on_monsters_found chp1"
	if (vdata.friends and #vdata.friends > 0) then
		for i=1, #vdata.friends do
			v_obj = vdata.friends[i]
			obj = alife():object(v_obj.id)
			if (obj and obj:name()==v_obj.name) then
				wpn = get_npc_weapon(obj)
				rank = obj:rank()
				health = obj:health()
				firepower = get_weapon_firepower(wpn)
				player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id), stalker_number = v_obj.stalker_number, stalker_map = v_obj.stalker_map}
				table_insert(team_A, player)
			end
		end
	end
  amk.oau_reason="on_monsters_found chp2"
	local params
	for i=1, #vdata.monsters do
  amk.oau_reason="on_monsters_found chp2.1"
		v_obj = vdata.monsters[i]
		obj = alife():object(v_obj.id)
  amk.oau_reason="on_monsters_found chp2.2"
		if (obj and obj:name() == v_obj.name) then
  amk.oau_reason="on_monsters_found chp2.3"
			params = get_monster_params(obj)
  amk.oau_reason="on_monsters_found chp2.4"
			if (params) then
  amk.oau_reason="on_monsters_found chp2.5"
				rank = obj:rank()
  amk.oau_reason="on_monsters_found chp2.6"
				health = obj:health()
  amk.oau_reason="on_monsters_found chp2.7"
				firepower = params.attack * base_fp
  amk.oau_reason="on_monsters_found chp2.8"
				player = {player = obj, speed = params.speed, attack_dist = params.dist, immunity = params.immunity, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id), monster_number = v_obj.monster_number, monster_map = v_obj.monster_map }
  amk.oau_reason="on_monsters_found chp2.9"
				table_insert(team_B, player)
  amk.oau_reason="on_monsters_found chp2.10"
			else
  amk.oau_reason="on_monsters_found chp2.11"
		end
	end
	end
  amk.oau_reason="on_monsters_found chp3"
	local distances = {}
	for a=1, #team_A do
		local from = team_A[a].player
		distances[from.id] = {}
		for b=1, #team_B do
			local to = team_B[b].player
			distances[to.id] = {}
			if (from and to and from.id and to.id) then
				local dist = math_floor(from.position:distance_to(to.position))
				local fp_A = math_floor(team_A[a].firepower / (dist / dist_coeff))
				local fp_B = math_floor(team_B[b].firepower)
				local item = {distance = dist, fpA = fp_A, fpB = fp_B}
				distances[from.id][to.id] = {distance = dist, fp = fp_A}
				distances[to.id][from.id] = {distance = dist, fp = fp_B}
			end
		end
	end
  amk.oau_reason="on_monsters_found chp4"
	-- Берем тех, у кого самый высокий rank и мин. distance
	table_sort(team_A, function(a,b) return a.rank > b.rank end)
	table_sort(team_B, function(a,b) return a.rank > b.rank end)
	-- 10 раундов
	local size_A = #team_A
	local size_B = #team_B
	local died_A = 0
	local died_B = 0
  amk.oau_reason="on_monsters_found chp5"
	for i=1, max_rounds do
		if (#team_A >0 and #team_B > 0) then
			local index = #team_A
			local attacker
			local defender
			local attack_info
			local rank_hit_chance
			local distance_hit_chance
			local hit_chance
			if (#team_B > index) then index = #team_B end
			for j = 1, index do
				attacker = team_A[j]
				defender = team_B[math_random(#team_B)]
				if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
					attack_info = distances[attacker.player.id][defender.player.id]
					-- Попал или нет? Зависит от: расстояния, рангов
					rank_hit_chance = math_floor((attacker.rank - defender.rank) / 50)
					local dii = math_floor(attack_info.distance - defender.speed * i * 5)
					if (dii <=8) then dii = 45 end -- Вблизи еще и фиг попадешь...
					distance_hit_chance = 100 - math_floor(dii / 1.5)					
					hit_chance = distance_hit_chance + rank_hit_chance
					if ((math_random() * 100) < hit_chance) then
						-- Попал таки, гад. Посмотрим, как сильно.
						if ( math_floor(attack_info.fp * defender.immunity) >= base_fp) then
							-- Все, убил.
							defender.health = 0
						else
							defender.health = defender.health - (attack_info.fp / base_fp) * defender.immunity
							if (defender.health < 0 ) then defender.health = 0 end							
						end
						if (defender.health <= 0) then
							if defender.flags >= 2 then
								defender.health = health_wound
							else
								-- Если сталкер - дадим опыт.
								if attacker.player and IAmAStalker[attacker.player:clsid()] and attacker.player.community then
									local m_comm  = attacker.player:community()
									if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
										-- Будет теперь опытным.
										local coeff = 1
										if (defender.rank < attacker.rank) then coeff = 0.5 end
										if (defender.rank > attacker.rank) then coeff = 2 end
										attacker.player:set_rank(attacker.player:rank() + math_floor(rate_kill_base * coeff))
									end
								end
								news_main.on_offline_death(defender.player, attacker.player, attacker.weapon)
								-- Заберем вещички с трупа
								local itA, v_itA
								local l_objA
								if (items[defender.player.id] and #items[defender.player.id] > 0) then
									for a=1,#items[defender.player.id] do
										v_itA = items[defender.player.id][a]
										if (v_itA) then
											itA = alife():object(v_itA.id)
											if (itA and itA:name()==v_itA.name and itA.parent_id == defender.player.id) then
												l_objA = pick_item(attacker.player, itA)
											else
												if(itA) then
													local mm = itA.parent_id
													if mm == nil then mm = "nil" end
												end											
											end			
										end
									end
								end
							end
						end
					end
				end
				-- team_B - защищается
				if (team_B[j] ~= nil) then
					attacker = team_B[j]
					defender = team_A[math_random(#team_A)]
					if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
						attack_info = distances[attacker.player.id][defender.player.id]
						-- Для начала неплохо бы узнать, добежал ли монстрик до дистанции атаки.
						if (attack_info.distance - attacker.speed * i * 5 < attacker.attack_dist) then
							rank_hit_chance = math_floor((attacker.rank - defender.rank) / 50)
							distance_hit_chance = 100
							hit_chance = distance_hit_chance + rank_hit_chance
							if math_random() * 100 < hit_chance then
								-- Попал таки, гад. Посмотрим, как сильно.
								if attack_info.fp >= base_fp then
									-- Все, убил.
									defender.health = 0
								else
									defender.health = defender.health - (attack_info.fp / base_fp)
									if (defender.health < 0 ) then defender.health = 0 end
								end
								if (defender.health == 0) then
									if defender.flags >= 2 then
										defender.health = health_wound
									else
										local coeff = 1
										if (defender.rank < attacker.rank) then coeff = 0.5 end
										if (defender.rank > attacker.rank) then coeff = 2 end
										news_main.on_offline_death(defender.player, attacker.player, nil)
										-- Забитрать вещички с трупа не будем. Хотя, может некоторые клептоманы...
										-- А вот труп грохнуть... Надо подумать :)
									end
								end
							end
						end
					end
				end
			end
		else
			-- Теперь и событие можно сформировать для новостей
			break
		end
		-- Почистим таблицы от трупов
		for kk, vv in pairs(team_A) do
			if (vv.health <=0) then
				set_npc_health(vv.player, 0)
				table_remove(team_A, kk)
				table_remove(off_npcs[vv.stalker_map].stalkers, vv.stalker_number)
				died_A = died_A + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				set_npc_health(vv.player, health_wound_set)
				news_main.on_offline_wound(vv.player)
				table_remove(team_A, kk)
				table_remove(off_npcs[vv.stalker_map].stalkers, vv.stalker_number)
			end
		end
		for kk, vv in pairs(team_B) do
			if (vv.health <=0) then
				set_npc_health(vv.player, 0)
				table_remove(team_B, kk)
				table_remove(off_npcs[vv.monster_map].monsters, vv.monster_number)
				died_B = died_B + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				set_npc_health(vv.player, health_wound_set)
				news_main.on_offline_wound(vv.player)
				table_remove(team_B, kk)
				table_remove(off_npcs[vv.monster_map].monsters, vv.monster_number)
			end
		end		
	end	
  amk.oau_reason="on_monsters_found end"
end

-- О, трупик. Щас шмонать будем.
function on_npc_corpses_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (vdata.corpses == nil) then return end
	if (vdata.corpses.stalkers == nil) then return end
	local obj, v_obj
	local id
	local v_id = victim.id
	for i=1, #vdata.corpses.stalkers do
		v_obj = vdata.corpses.stalkers[i]
		local corpse = alife():object(v_obj.id)
		if (corpse and corpse:name() == v_obj.name) then
			news_main.on_offline_corpse_found(victim, corpse)
			id = corpse.id
			if (id and items[id]) then
				for a=1, #items[id] do
					local v_itA = items[id][a]
					if (v_itA) then
						local itA = alife():object(v_itA.id)
						if (itA and itA:name() == v_itA.name and itA.parent_id == id) then
							local l_objA = pick_item(victim, itA)
						end			
					end
				end
			end
		end
	end
end

-- О, трупик монстра. Будем шмонать?
function on_monster_corpses_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (vdata.corpses == nil) then return end
	if (vdata.corpses.monsters == nil) then return end
	local obj, v_obj
	local object
	local id
	local v_id = victim.id
	for i=1, #vdata.corpses.monsters do
		v_obj = vdata.corpses.monsters[i]
		local corpse = alife():object(v_obj.id)
		if (corpse and corpse:name() == v_obj.name) then
			news_main.on_offline_corpse_found(victim, corpse)		
			id = corpse.id
			if (id and items[id]) then
				for a=1, #items[id] do
					local v_itA = items[id][a]
					if (v_itA) then
						local itA = alife():object(v_itA.id)
						if (itA and itA:name() == v_itA.name and itA.parent_id == id) then
							local l_objA = pick_item(victim, itA)
						end			
					end
				end
			end
		end
	end
end

-- Хорошая пушка - не помешает.
function on_weapons_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	local obj, v_obj
	local object
	local v_id = victim.id
	for i=1, #vdata.weapons.seen do
		v_obj = vdata.weapons.seen[i]
		if (v_obj) then
			object = alife():object(v_obj.id)
			if (object and object:name() == v_obj.name) then
				obj = pick_item(victim, object)
			end
		end
	end
end

-- Моя прелесссть
function on_artifacts_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	local obj, v_obj
	local object
	local v_id = victim.id
	local b_stalker = false
	-- Если сталкер - дадим опыт.
	if victim and IAmAStalker[victim:clsid()] and victim.community then
		if is_good_stalker[victim:community()] then
			b_stalker = true
		end
	end
	for i=1, #vdata.artefacts do
		v_obj = vdata.artefacts[i]
		if (v_obj) then
			object = alife():object(v_obj.id)
			if (object and object:name() == v_obj.name) then
				obj = pick_item(victim, object)
				if (obj) then
					if (b_stalker == true) then
						victim:set_rank(victim:rank() + rate_art_found)
					end
				end
			end
		end
	end
end

-- О, нычка - это гуд.
-- Idler ++
-- проверим, а сможет ли непись долезть до  тайника.
-- если есть аномалии в радиусе 20м, меньше шансов или если тайник высоко, тоже не факт что долезет.
function inv_box_is_avail(victim, box)
	if (victim == nil or box == nil or box.id == 0) then return false end

	local n_rnd
	if victim.position and box.position then 
		n_rnd = math_random(3, 10)
		if math_abs(box.position.y - victim.position.y) > n_rnd then
			return false
		end 
	end

	local anom_list=amk_anoms.get_anomaly_list_for_pos(box.position,20) 
	local n_anoms = #anom_list
	n_rnd = math_random(1, 100)
	if n_rnd < n_anoms * 20 then -- смотрим вероятность. Чем больше аномалий, тем меньше шансов. При 5 - точно до ящика не доберется
		return false
	end
	return true
end
-- Idler --

function on_inv_boxes_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	local obj, v_obj
	local object
	local v_id = victim.id
	local b_stalker = false
	-- Если сталкер - дадим опыт.
	if victim and IAmAStalker[victim:clsid()] and victim.community then
		if is_good_stalker[victim:community()] then
			b_stalker = true
		end
	end
	for i=1, #vdata.inv_boxes do
		v_obj = vdata.inv_boxes[i]
		if (v_obj and allow_box) then -- DC --
			object = alife():object(v_obj.id)
			if (object and object:name() == v_obj.name) then
				if inv_box_is_avail(victim, object) then  -- Idler ++-- если нычка доступна - можно шмонать
					if items[v_obj.id] and #items[v_obj.id]>0 then
						for a=1,#items[v_obj.id] do
							local v_itA = items[v_obj.id][a]
							if (v_itA) then
								local itA = alife():object(v_itA.id)
								if (itA and itA:name()==v_itA.name and itA.parent_id == v_obj.id) then
									-- Решим, подбираем или нет?
									local bTake = is_valuable(itA)
									if bTake then
										local l_objA = pick_item(victim, itA)
									end
								else
									if(itA) then
										local mm = itA.parent_id
										if mm == nil then mm = "nil" end
									end											
								end			
							end
						end					
					end
				end
			end
		end
		if (b_stalker == true) then
			victim:set_rank(victim:rank() + rate_art_found)
		end
	end
end

function pick_item(npc, obj)
	local new = nil
	if (npc and obj and db.actor and obj.id ~= db.actor:id()) then
		local o, n, pid = obj:name() or "===nil===", npc:name() or "===nil===", obj.parent_id
		local p, pn = nil, "===nil==="
		if pid then p = alife():object(pid) end
		if p then pn = p:name() or "===nil===" end
		local section = obj:section_name()
		new = alife():create(section, npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, npc.id)
		if (new) then
			if (new.parent_id) then
				if not items[new.parent_id] then items[new.parent_id] = {} end
				table_insert(items[new.parent_id], {id = new.id, name = new:name()})
gps_habar.insert_item(new.parent_id, new) -- Idler++-- корректируем хабар в помеченных тайниках
			end
			if (obj.parent_id and items[obj.parent_id] and #items[obj.parent_id]>0) then
				for z=1, #items[obj.parent_id] do
					if (items[obj.parent_id][z] and items[obj.parent_id][z].id == obj.id) then
gps_habar.remove_item(obj.parent_id, items[obj.parent_id][z]) -- Idler++-- корректируем хабар в помеченных тайниках
						table_remove(items[obj.parent_id], z)
						break
					end
				end
			end
			alife():release(alife():object(obj.id), true)
		end
	end
	return new
end

function get_npc_weapon(npc)
	local obj
	local fp = 0
	sim = alife()
	local obj_list = items and npc and npc.id and items[npc.id]
	if obj_list and sim then
		for i = 1,#obj_list do
			local v = obj_list[i]
			local obj_id = v and v["id"]
			local wpn = obj_id and sim:object(obj_id)
			if wpn and IAmAWeaponFireOnly[wpn:clsid()] and wpn:name() == v.name and wpn.parent_id == npc.id then
				local sect = wpn:section_name()
				local cur_fp = 0
				local modes = rx_wmgr.read_wm_modes(npc:community(),ranks.get_obj_rank_name(npc),npc:section_name())
				local params = rx_wmgr.read_wpn_params(sect)
				if modes.mode1 == "1" then cur_fp = params.cst + modes.addcost
				elseif modes.mode1 == "2" then
					local kf = rx_wmgr.wm_modes.koeffs[modes.koeffs]
					cur_fp = (params.dmg*kf.dmg)+(params.rpm*kf.rpm)+(params.dst*kf.dst)+((100/params.dsp)*kf.dsp)
				elseif modes.mode1 == "3" then cur_fp = rx_wmgr.wm_modes.priors[modes.priors][sect]
				end
				if cur_fp > fp then
					fp = cur_fp
					obj = wpn
				end
	end     end	end
	return obj
end

function get_weapon_firepower(wpn)
	local result = 0
	if wpn then
		local cls_id = wpn:clsid()
		if IAmAWeaponFireOnly[cls_id] then
			local sect = wpn:section_name()
			if wpn_fp[sect] then result = wpn_fp[sect]
			else
				local priority = getIniValueFloatSimple(sect, "ef_weapon_type", 1)
				local priority2 = getIniValueFloatSimple(sect, "ef_main_weapon_type", 0)
				local GetRPM = ui_wpn_params.GetRPM(sect)
				local GetDamage = ui_wpn_params.GetDamage(sect)
				local GetHandling = ui_wpn_params.GetHandling(sect)
				local GetAccuracy = ui_wpn_params.GetAccuracy(sect)
				local fp = 1
				if priority>1 then
					if priority2>0 then priority = priority + priority2 end
				end
				fp = math_ceil(priority * 1000 + GetAccuracy * 100 + GetRPM * 3 + GetDamage * 8) - 5000
				if GetHandling >= 99 then fp = fp + 1500 end
				result = fp
				wpn_fp[sect] = fp
			end
		end
	end
	return result
end

function get_weapon_cost(weapon)
	local sect = weapon:section_name()
	if (weapon and IAmAWeapon[weapon:clsid()]) then return getIniValueFloatSimple(sect, "cost", 0)	end
	return 0
end

function get_item_cost(item)
	if (item and item.section_name) then return getIniValueFloatSimple(item:section_name(), "cost", 0) end
	return 0
end

function set_npc_health(obj, health)
	if (obj and health >=0 and health <=2) then
		if IAmAMonster[obj:clsid()] or IAmAStalker[obj:clsid()] then
			--
			local pk = get_netpk( obj )
			ASSERT( ( pk and pk:isOk() ), "can't read netpacket of %s", obj:name() )
			local data = pk:get()
			data.health = 0
			data.upd.health = 0
			pk:set( data )
			--
		end
		if health == 0 then
			on_death(obj.id)
		end
	end
end

function list_npc_items(obj)
	local sim = alife()
	if (obj) then
		local it
		local find = 0
		for a=1,65534 do
			it = sim:object(a)
			if (it and it.parent_id == obj.id) then
				if (IAmAWeapon[it:clsid()]) then
					find = it.id
				end
			end
		end
	end
end

-- Строим таблицы, если надо.
-- В них - макс. скорость, сила атаки, дистанция атаки.
-- Не забываем про иммунитеты.
-- Поучаем immunities_sect
-- В immunities_sect читаем fire_wound_immunity. Все повреждения множим на него.
function get_monster_params(obj)
  amk.oau_reason="get_monster_params chp1"
  local sect = obj:section_name()
	if (obj and IAmAMonster[obj:clsid()]) or (obj and obj.community and obj:community()=="zombied") then
  amk.oau_reason="get_monster_params chp2"
		if (monster_params and monster_params[sect]) then
  amk.oau_reason="get_monster_params chp3"
			return monster_params[sect]
		else
  amk.oau_reason="get_monster_params chp4"
			-- local speed 	= utils.cfg_get_number(system_ini(), obj:section_name(), "MaxSpeed", obj, false, 5)
			local speed 	= getIniValueFloatSimple(sect, "MaxSpeed", 5)
  amk.oau_reason="get_monster_params chp5"
			-- local dist 	= utils.cfg_get_number(system_ini(), obj:section_name(), "MaxAttackDist", obj, false, 3)
			local dist 		= getIniValueFloatSimple(sect, "MaxAttackDist", 3)
  amk.oau_reason="get_monster_params chp6"
			-- local imm_sect = utils.cfg_get_string(system_ini(), obj:section_name(), "immunities_sect", obj, false, "", "")
			local imm_sect 	= getIniValueStringSimple(sect, "immunities_sect", "")
  amk.oau_reason="get_monster_params chp7"
			-- local immunity 	= utils.cfg_get_number(system_ini(), imm_sect, "fire_wound_immunity", obj, false, 1)
			local immunity 	= getIniValueFloatSimple(imm_sect, "fire_wound_immunity", 1)
  amk.oau_reason="get_monster_params chp8"
			-- local att_sect 	= utils.cfg_get_string(system_ini(), obj:section_name(), "attack_params", obj, false, "", "")
			local att_sect 	= getIniValueStringSimple(sect, "attack_params", "")
  amk.oau_reason="get_monster_params chp9"
			local attack	= 0
  amk.oau_reason="get_monster_params chp10 "..tostring(att_sect)
			if (iniSectionExistSimple(att_sect)) then
  amk.oau_reason="get_monster_params chp11"
				local result, id, value = nil, nil, nil
				local max_attack = 0
  amk.oau_reason="get_monster_params chp12"
				for a=0, iniLinesCountSimple(att_sect)-1 do
  amk.oau_reason="get_monster_params chp13"
					result, id, value = getIniLineSimple(att_sect,a,"","")
  amk.oau_reason="get_monster_params chp14"
					if id~=nil and trim(id)~="" and trim(id)~=nil and value~=nil then
  amk.oau_reason="get_monster_params chp15"
						local m_value = Parse_StrToTbl(value, ",")
  amk.oau_reason="get_monster_params chp16"
						if (m_value and #m_value>2) then
  amk.oau_reason="get_monster_params chp17"
							local v = tonumber(m_value[2])
  amk.oau_reason="get_monster_params chp18"
							if (v and v > max_attack) then					
  amk.oau_reason="get_monster_params chp19"
								max_attack = v
							end
						end
					end
				end
  amk.oau_reason="get_monster_params chp20"
				attack = max_attack
			end
			monster_params[sect] = {speed = speed, dist = dist, immunity = immunity, attack = attack}
			return monster_params[sect]			
		end
	else
		return nil
	end
end

function sobj_is_far(obj, distance)
	local result = true
	if (db.actor and obj and distance and obj.position and db.actor.position ) then
		-- на одном ли уровне?
		if obj.m_game_vertex_id and game_graph():valid_vertex_id(obj.m_game_vertex_id) then
		local map = alife():level_name(game_graph():vertex(obj.m_game_vertex_id):level_id())
		if (map and level.name() == map) then
			-- Достаточно ли далеко?
			if (obj.position:distance_to(db.actor:position()) < distance) then
				result = false
			end
		end
   end
   end
   return result
end

function have_ammo(npc, weapon)
	local result = false
	local sect = weapon:section_name()
	if npc and weapon and IAmAStalker[npc:clsid()] and IAmAWeapon[weapon:clsid()] then
		-- local ammo_str = utils.cfg_get_number(system_ini(), weapon:section_name(), "ammo_class", weapon, false, "")
		local ammo_str = getIniValueFloatSimple(sect, "ammo_class", "")
		if ammo_str=="" then -- Болт или граната
			return false
		end
	end
	return result
end

function box_is_protected(v)
	local result = v and (protected.ids[v.id] or protected.story_ids[v.m_story_id] or protected.names[v:name()] or protected.sections[v:section_name()] )
	return result
	--[[if v then
		local name = v:name()
		local id = v.id
		local sid = v.m_story_id
		
		-- проверяем по имени объекта
		for k, o in pairs(protected.names) do
			if o == name then
				return true
			end
		end
		
		-- проверяем по ID объекта
		for k, o in pairs(protected.ids) do
			if o == id then
				return true
			end
		end
		
		-- проверяем по story ID объекта
		for k, o in pairs(protected.story_ids) do
			if o == sid then
				return true
			end
		end
	end
	return false]]
end

function npc_smart_is_peaceful(sobj)
	--local result = false
	if sobj and #smart_filters > 0 then
		if sobj.smart_terrain_id then
			local smrt_tr_id = sobj:smart_terrain_id()
			if smrt_tr_id and smrt_tr_id ~= 65535 then
				local sm = alife():object(smrt_tr_id)
				if sm and sm.name then
					local sn = sm:name()
					if sn and smart_filters[sn] then
						return true
						--[[for ks, vs in pairs(smart_filters) do
							if vs == sn then
								-- Ага, он у нас мирный.
								result = true
								break
							end
						end]]
					end
				end
			end
		end
	end
	return false
end

function on_death(npc_id)
	smart_terrain.on_death( npc_id )
end

function get_flags(npc_id)
	local flags = 0
	local obj = alife():object(npc_id)
	if obj then
		if IAmAMonster[obj:clsid()] or IAmAStalker[obj:clsid()] then
			local char_ini = xr_logic.get_customdata_or_ini_file(obj, "<customdata>")
			if char_ini:section_exist("logic") then
				local from = ""
				local items = ""
				if char_ini:line_exist("logic", "on_hit") then
					flags = 1
				end
				if char_ini:line_exist("logic", "on_death") then
					flags = flags + 2
				end
			end
		end
	end
	return flags
end

function is_valuable(item)
	local result = false
	if item and not (IAmAMonster[item:clsid()] or IAmAStalker[item:clsid()]) 
		and (protected_items.doNotTouchItemEquipment(item) or always_keep_item[item:section_name()] ) then
-- or sell_table[item:section_name()] == nil) then
		
		local cost = get_item_cost(item)
		if IAmAWeapon[item:clsid()] and cost >= 1000 then
			result = true
		elseif cost >= 800 then
			result = true
		end
	end
	return result
end
