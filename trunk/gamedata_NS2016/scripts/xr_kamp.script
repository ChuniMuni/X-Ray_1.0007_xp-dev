local visualWithHemlet = {
["stalker_arhara"] = true,
["stalker_arhara1"] = true,
["stalker_bandit_8"] = true,
["stalker_bandit_exoskeleton"] = true,
["stalker_do_antigas"] = true,
["stalker_do_exoskeleton"] = true,
["stalker_do_nauchniy"] = true,
["stalker_ecolog"] = true,
["stalker_ecolog_0_zombie"] = true,
["stalker_ecolog_1_zombie"] = true,
["stalker_ecolog_2_zombie"] = true,
["stalker_ecolog_military"] = true,
["inkvizitor_cherep"] = true,
["inkvizitor_exolight"] = true,
["inkvizitor_light"] = true,
["inkvizitor_redeye"] = true,
["stalker_ki_antigas"] = true,
["stalker_ki_exoskeleton"] = true,
["stalker_ki_nauchniy"] = true,
["stalker_militari_1"] = true,
["stalker_militari_2"] = true,
["stalker_militari_antigas_1"] = true,
["stalker_militari_antigas_2"] = true,
["stalker_mo_exo"] = true,
["stalker_mo_hood_9"] = true,
["stalker_mo_nauchniy"] = true,
["nauchniy_0"] = true,
["nauchniy_1"] = true,
["stalker_nebo_balon_1"] = true,
["stalker_nebo_exoskeleton"] = true,
["stalker_nebo_nauchniy"] = true,
["stalker_2_gas"] = true,
["stalker_3_gas"] = true,
["stalker_3_gas_"] = true,
["stalker_4_gas"] = true,
["stalker_4_gas_"] = true,
["stalker_ne_exoskeleton"] = true,
["stalker_neytral_exoskeleton"] = true,
["stalker_neytral_hood_9"] = true,
["stalker_neytral_hood_92"] = true,
["stalker_neytral_nauchniy"] = true,
["green_stalker_antigas"] = true,
["protect_suit1"] = true,
["protect_suit2"] = true,
["nauchniy_pozarnik"] = true,
["nauchniy_white"] = true,
["soldier_antigas"] = true,
["stalker_military_black"] = true,
["stalker_military_green"] = true,
["stalker_rus_spec"] = true,
["stalker_zp_exoskeleton"] = true,
["stalker_killer_antigas"] = true,
["stalker_killer_exoskeleton"] = true,
["stalker_killer_military"] = true,
["stalker_sci_killer"] = true,
["stalker_sci_svoboda"] = true,
["stalker_sv_exoskeleton"] = true,
["stalker_sv_hood_9"] = true,
["stalker_sv_military"] = true,
["zombie_exoskeleton"] = true,
["stalker_sv_exoskeleton"] = true,
["stalker_sv_hood_9"] = true,
["stalker_sv_hood_91"] = true,
["stalker_sv_nauchniy"] = true,
["exoskelet_black"] = true,
["stalker_ecologi_2exoskeleton"] = true,
["stalker_kalinin_exoskeleton"] = true,
["boss"] = true,
["frits"] = true,
["stalker_bandit_9"] = true,
["stelsarmor_danekstalker"] = true,
["zaton_prototip"] = true,
["zaton_prototip1"] = true
}



----------------------------------------------------------------------------------------------------------------------
--	Схема лагерь. Чудак(и) у костра.
--	автор: Диденко Руслан (Stohe)
--	TODO: 
----------------------------------------------------------------------------------------------------------------------
local table_remove = table.remove
local table_insert = table.insert
local string_find = string.find
local deadmanMovingBone = "bip01_spine1"
local deadmanMovingBone2 = "bip01_pelvis"
local deadmanAdditionalForce = {
	["m_tushkano_e"] = 0.5,
	["m_tushkano_normal"] = 0.5,
	["tushkano_weak"] = 0.5,
	["tushkano_normal"] = 0.5,
	["tushkano_strong"] = 0.5,
	["m_rat_e"] = -0.4,
	["rat_weak"] = -0.4,
	["rat_normal"] = -0.4,
	["rat_strong"] = -0.4,
}

local scan_flag
kamps = {}
kamp_stalkers = {} -- могут ли сталкеры в лагере юзаться игроком.
-- Объявления итераторов
deadmansMoversIds={} -- кто какой труп оттаскивает
deadmansidsuses={} -- сколько попыток оттащить было сделано
local k,v,kk,vv = 0,0,0,0
---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
--' Условие завершения скрипта
class "evaluator_kamp_end" (property_evaluator)
function evaluator_kamp_end:__init(name, storage) super (nil, name)
	self.a = storage
end
function evaluator_kamp_end:evaluate()
	local kamp_end = not xr_logic.is_active(self.object, self.a)
	return kamp_end
end
--' Находимся ли мы на заданной позиции
class "evaluator_on_position" (property_evaluator)
function evaluator_on_position:__init(name, storage) super (nil, name)
	self.a = storage
end
function evaluator_on_position:evaluate()
	return self.object:level_vertex_id() == self.a.pos_vertex
end

--added by xStream--
--' Оп-па! Увидели труп поблизости от костра, непорядок...
-- исключение чтобы не таскали и не тырили деньги
exclude_corpses = {
	["muha_die"] = true
}
class "evaluator_see_deadman" (property_evaluator)

function evaluator_see_deadman:__init(name, storage) super (nil, name)
	self.a = storage
	self.a.scan_time = time_global() + 5555
end

function evaluator_see_deadman:evaluate()
	local st = self.a
	local npc = self.object
	local npc_id = npc:id()
	if self.mgr == nil then self.mgr = self.object:motivation_action_manager() end
	-- Есть дела поважнее, чем трупы складировать...
	if not xr_logic.is_active(self.object, st) or self.mgr:evaluator(stalker_ids.property_enemy):evaluate() or self.mgr:evaluator(stalker_ids.property_danger):evaluate() then
		if st.choosed_deadman then 
			deadmansMoversIds[st.choosed_deadman] = nil
			deadmansidsuses[st.choosed_deadman] = 0
			st.choosed_deadman = nil
			st.reached = nil
		end
		return false
	end

	-- Труп себе уже выбрали, не спускаем с него глаз...
	local center_pos = patrol(st.center_point):point(0)
	local npc_pos = npc:position()
	local actor_pos = db.actor:position()
	local actor_alive = db.actor:alive()
	if st.choosed_deadman then 
		local obj = level.object_by_id(st.choosed_deadman)
		local watcher = watcher_act and watcher_act.obj_owner and watcher_act.obj_owner[st.choosed_deadman] and level.object_by_id(watcher_act.obj_owner[st.choosed_deadman])
		if obj and level.vertex_position(obj:level_vertex_id()):distance_to_sqr(center_pos) < 400
		and (not watcher or not watcher:alive() or xr_wounded.is_wounded(watcher) or watcher:position():distance_to_sqr(level.vertex_position(obj:level_vertex_id())) > 4) then
			return true
		end
		-- если утащен далеко, то ну его нафиг...
		deadmansMoversIds[st.choosed_deadman] = nil
		deadmansidsuses[st.choosed_deadman] = 0
		st.choosed_deadman = nil
		st.reached = nil
		return false
	end
	
	if st.scan_time > time_global() then
		return false
	else
		st.scan_time = time_global() + 5555
	end
	
	local deadmansMovableNearest, deadmansMovableDist = nil, 10000
	
	local function check_item(o)
		local obj=o:object()
		if obj then	--если есть рядом с костром труп сталкера или монстра, его еще никто не прихватил себе и трупец нигде не застрял, то забираем его...
			local obj_id = obj:id()
			
			if npc_by_clsid[obj:clsid()] and not obj:alive() and not exclude_corpses[obj:name()] then
				local obj_pos = level.vertex_position(obj:level_vertex_id())
				local deadman = deadmansMoversIds[obj_id] and level.object_by_id(deadmansMoversIds[obj_id])
				local y = vector():sub(center_pos, obj_pos).y
				if (not deadman or not deadman:alive() or xr_wounded.is_wounded(deadman)) and obj_pos:distance_to_sqr(center_pos)<100 and (not actor_alive or actor_pos:distance_to_sqr(obj_pos) > 4) and math.abs(y) < 2.5 then
					if not deadmansidsuses[obj_id] or deadmansidsuses[obj_id] < 6 then
						local watcher = watcher_act and watcher_act.obj_owner and watcher_act.obj_owner[obj_id] and level.object_by_id(watcher_act.obj_owner[obj_id])
						if not watcher or not watcher:alive() or xr_wounded.is_wounded(watcher) or watcher:position():distance_to_sqr(level.vertex_position(obj:level_vertex_id())) > 25 then
							if obj_pos:distance_to_sqr(npc_pos) < deadmansMovableDist then
								deadmansMovableDist = obj_pos:distance_to_sqr(npc_pos)
								deadmansMovableNearest = obj
							end
						end
					end
				end
			end
		end
	end	
	for o in npc:memory_visible_objects() do if check_item(o) then return true end end
	
	if deadmansMovableNearest ~= nil then
		local obj_id = deadmansMovableNearest:id()
		deadmansMoversIds[obj_id]=npc_id
		st.choosed_deadman=obj_id
		-- ...заодно сразу прикидываем, куда бы его оттащить от костра, желательно под забор, стену дома и т.п., 
		-- за неимением таковых - будем тащить куда попало, главное - подальше от костра
		st.drop_lvid=npc:level_vertex_id()
		
		local center = deadmansMovableNearest:level_vertex_id()
		local max_dist=0
		local tgt_vertex=nil
		local base_dir = level.vertex_position(deadmansMovableNearest:level_vertex_id()):sub(center_pos)
		local base_point=deadmansMovableNearest:level_vertex_id()
		local cur_vert
		local dist
		for ang = -120,120,20 do
			cur_vert = npc:vertex_in_direction(base_point,vector_rotate_y(base_dir,ang),25)
			dist = level.vertex_position(cur_vert):distance_to_sqr(center_pos)
			if dist > 121 and dist < 650 and dist > max_dist then
				max_dist = dist
				tgt_vertex = cur_vert
			end
		end
		if tgt_vertex == nil then
			tgt_vertex = npc:vertex_in_direction(base_point,vector_rotate_y(base_dir,math.random()*180-90),25)
		end

		st.drop_lvid = tgt_vertex
		st.ps = deadmansMovableNearest:get_physics_shell()

		return true
	end
	return false
end

--' Тащим труп
class "evaluator_can_move_deadman" (property_evaluator)
function evaluator_can_move_deadman:__init(name, storage) super (nil, name)
	self.a = storage
end
function evaluator_can_move_deadman:evaluate()
	local npc = self.object
	local obj = level.object_by_id(self.a.choosed_deadman)
	--если труп застрял (расстояние увеличилось), то возвращаемся к нему
	--или если ГГ подошел, то уделяем ему чуточку внимания
	if self.a.reached == 1 and obj then
		local bone_pos = obj:bone_position(deadmanMovingBone)
		local can = bone_pos:distance_to_sqr(npc:position()) < 9 and (not db.actor:alive() or bone_pos:distance_to_sqr(db.actor:position()) > 9)
		return can
	end
	return false
end
--end--
----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
-- перемешанный вариант (диаметрально противоположные пары)
	-- радиус 1.2, начало в 360/5/2 градусов, поворот на 360/5
	-- радиус 0.8, начало в 0 градусов, поворот на 360/5
local positionTemplate = {
	{0.9708203932,	0, -0.7053423028},
	{-0.6472135955,	0, 0,4702282018},

	{0.9708203932,	0, 0.7053423028},
	{-0.6472135955,	0, -0.4702282018},
	
	{-0.3708203932,	0, 1.1412678196},
	{0.2472135955,	0, -0.760845213},
	
	{-1.2,			0, 0.0},
	{0.8,			0, 0.0},
	
	{-0.3708203932,	0, -1.1412678196},
	{0.2472135955,	0, 0,760845213}
}
--' Идет в заданную область
class "action_go_position" (action_base)
function action_go_position:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_go_position:initialize()
	action_base.initialize(self)
	self.object:set_desired_position()
	self.object:set_desired_direction()
	
	self.a.pos_vertex = nil
	kamps[self.a.center_point]:addNpc(self.object)
	self.mv_timeout = time_global() + 5000
end


function action_go_position:execute ()
	action_base.execute (self)
	if db.actor then
		if xr_logic.try_switch_to_another_section(self.object, self.a, db.actor) then
			return
		end
	end	
	
	local tmp_pos_vertex = kamps[self.a.center_point]:getDestVertex(self.object:id(), self.a.radius)
	if self.a.pos_vertex ~= tmp_pos_vertex then
		self.a.pos_vertex = tmp_pos_vertex
		
		if not self.object:accessible(self.a.pos_vertex) then
			local ttp = vector():set(0,0,0)
			self.a.pos_vertex = self.object:accessible_nearest(level.vertex_position(self.a.pos_vertex), ttp)
		end
		
		self.a.pp = patrol(self.a.center_point):level_vertex_id(0)
		self.object:set_dest_level_vertex_id(self.a.pos_vertex)
		self.object:set_desired_direction(vector():sub(level.vertex_position(self.a.pp),level.vertex_position(self.a.pos_vertex)))
		self.object:set_path_type(game_object.level_path)
		state_mgr.set_state(self.object, self.a.def_state_moving)
	end
	local global_time = time_global()
	if self.mv_timeout < global_time then
		local npc = self.object
		local st = self.a
		local lvid = npc:level_vertex_id()
		if lvid ~= self.mv_lvid then
			npc:set_path_type( game_object.level_path )
			state_mgr.set_state( npc, st.def_state_moving )
			self.mv_timeout = global_time + 5000
		else
			npc:set_path_type( game_object.game_path )
			state_mgr.set_state( npc, "run" )
			self.mv_timeout = global_time + 15000
		end
		self.mv_lvid = lvid
	end

end


function action_go_position:finalize ()
	action_base.finalize (self)
end

--' Просто сидит и втыкает
class "action_wait" (action_base)
function action_wait:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_wait:initialize()
	action_base.initialize(self)
	self.object:set_desired_position()
	self.object:set_desired_direction()
	kamps[self.a.center_point]:addNpc(self.object)
end
function action_wait:activate_scheme()
	--kamps[self.a.center_point]:addNpc(self.object)
end
function action_wait:execute()
	action_base.execute (self)
	if db.actor then
		if xr_logic.try_switch_to_another_section(self.object, self.a, db.actor) then
			return
		end
	end
	local state, sound, substate = kamps[self.a.center_point]:updateNpc(self.object,self.a)
	--' повернуть его лицом к центру	
	state_mgr.set_state(self.object, state, nil, nil, {look_position = level.vertex_position(self.a.pp)}, nil, nil, {subanim = substate})
	xr_sound.set_sound(self.object, sound)
end
function action_wait:finalize()
	kamps[self.a.center_point]:removeNpc(self.object)
	action_base.finalize (self)
end
function action_wait:deactivate(npc)
	kamps[self.a.center_point]:removeNpc(npc)
end
function action_wait:death_callback(npc)
	kamps[self.a.center_point]:removeNpc(npc)
end
function action_wait:hit_callback(npc)
---	kamps[self.a.center_point]:removeNpc(npc)
end
function action_wait:net_destroy(npc)
	kamps[self.a.center_point]:removeNpc(npc)
end
--added by xStream--
--Идет к бездыханному товарищу
class "action_go_to_deadman" (action_base)
function action_go_to_deadman:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_go_to_deadman:initialize()
	action_base.initialize(self)
	local npc=self.object
	local gi=level.object_by_id(self.a.choosed_deadman)
	if gi then 
		--попремся в сторону головы - за шкирятник тащить бум
		self.a.dest_lvid=gi:level_vertex_id()
		local diff=gi:bone_position("bip01_head"):sub(gi:position())
		local len=diff:magnitude()*2
		self.a.dest_lvid=npc:vertex_in_direction(self.a.dest_lvid,diff,len)
		if not npc:accessible(self.a.dest_lvid) then
			self.a.dest_lvid = npc:accessible_nearest(level.vertex_position(self.a.dest_lvid), vector():set(0,0,0))
		end
	else
		self.a.dest_lvid=npc:level_vertex_id()
	end
	self.a.reached=0
	self.a.cur_dead_lvid=gi:level_vertex_id()
	--пойдем не спеша...
	state_mgr.set_state(self.object, self.a.def_state_moving)
	npc:set_detail_path_type(move.curve)
			npc:set_path_type(game_object.level_path)
				npc:set_mental_state(anim.danger)
				npc:set_body_state(move.standing)
				local mt = npc:movement_type()
				npc:movement_enabled(true)

	--на все гулянки в сторону трупа дается 30 секунд, если не успел, то да ну нафиг заморачиваться :)
	self.a.go_time_end=time_global()+300000
	self.a.captures = (self.a.captures or 0) + 1
	xr_sound.set_sound(npc, nil)
	stop_play_sound(npc)
end

function action_go_to_deadman:execute ()
	action_base.execute (self)
	local npc=self.object
	local gi = self.a.choosed_deadman and level.object_by_id(self.a.choosed_deadman)
	-- если уже задолбало дергать труп, а он застрял (дергаем 5 раз), то нафиг его
	if not gi or self.a.captures==6 or self.a.go_time_end<time_global() then
		deadmansidsuses[self.a.choosed_deadman] = (deadmansidsuses[self.a.choosed_deadman] or 0) +1
		deadmansMoversIds[self.a.choosed_deadman]=nil
		self.a.choosed_deadman=nil
		self.a.reached=nil
		self.a.captures=nil
	else
		-- корректировка (sapsan)
		--попремся в сторону головы - за шкирятник тащить бум
		self.a.dest_lvid=gi:level_vertex_id()
		local diff=gi:bone_position("bip01_head"):sub(gi:position())
		local len=diff:magnitude()*2
		self.a.dest_lvid=npc:vertex_in_direction(self.a.dest_lvid,diff,len)
		if not npc:accessible(self.a.dest_lvid) then
			self.a.dest_lvid = npc:accessible_nearest(gi:bone_position("bip01_head"), vector():set(0,0,0))
		end

		npc:set_dest_level_vertex_id(self.a.dest_lvid)
		-- долгое путешествие до трупа успешно завершилось, ура, товарищи
		if self.a.dest_lvid and self.a.dest_lvid==npc:level_vertex_id() or npc:position():distance_to_sqr(level.vertex_position(self.a.dest_lvid)) < 1.5 then
			self.a.reached=1
		end
	end
end

function action_go_to_deadman:finalize ()
	local gi = self.a.choosed_deadman and level.object_by_id(self.a.choosed_deadman)
	-- если уже задолбало дергать труп, а он застрял (дергаем 5 раз), то нафиг его
	if not gi or self.a.captures==6 or self.a.go_time_end<time_global() then
		if self.a.choosed_deadman then
			deadmansMoversIds[self.a.choosed_deadman]=nil
			self.a.choosed_deadman=nil
		end
		self.a.reached=nil
		self.a.captures=nil
	end

	action_base.finalize (self)
end

--Тащит трупец
class "action_moving_deadman" (action_base)
function action_moving_deadman:__init (npc_name,action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_moving_deadman:initialize()
	action_base.initialize(self)
  local npc=self.object
  --если пушка в руках - прячем, а то тащить неудобно
  if npc:weapon_unstrapped() then
    npc:set_item(object.idle,nil)
  end
	--потащим медленно, осторожно и на карачках
	npc:set_movement_type(move.walk)
	npc:set_mental_state(anim.danger)
	npc:set_body_state(move.crouch)
	npc:movement_enabled(true)

	--на таскание трупа в грязи даем 40 секунд
  self.a.time_end=time_global()+40000
  self.force=vector():set(0,0,0)
	--на приседание рядом с трупом и разворот лицом дадим секунду
  self.time_drag=time_global()+1000
  
  deadmansidsuses[self.a.choosed_deadman] = (deadmansidsuses[self.a.choosed_deadman] or 0) +1
end

function action_moving_deadman:execute ()
	action_base.execute (self)
	local npc=self.object
	local gi = self.a.choosed_deadman and level.object_by_id(self.a.choosed_deadman)

	if not gi or self.a.captures==6 or self.a.time_end<time_global() then	--хватит таскать труп - время истекло, пусть другие этим занимаются
		deadmansidsuses[self.a.choosed_deadman] = (deadmansidsuses[self.a.choosed_deadman] or 0) +1
		deadmansMoversIds[self.a.choosed_deadman] = nil
		self.a.choosed_deadman = nil
		self.a.reached = nil
		self.a.captures=nil
		return 
	end


	local dir=gi:position():sub(npc:position())	-- смотри мне в глаза !
	dir.y=0
	npc:set_movement_type(move.walk)
	npc:set_mental_state(anim.danger)
	npc:set_body_state(move.crouch)
	npc:movement_enabled(true)
	npc:set_sight(look.direction,dir,true)

	if self.a.ps and self.time_drag<time_global() then
		npc:set_dest_level_vertex_id(self.a.drop_lvid)
		-- непись сильный - тащит левой рукой за туловище трупа
		local dir=npc:bone_position("bip01_l_hand"):sub(gi:bone_position(deadmanMovingBone))
		dir:mul(25000)
		dir.y=9000
		self.force:mul(0.5)
		local addForce = npc:bone_position("bip01_l_hand"):distance_to(gi:bone_position(deadmanMovingBone))/1
		dir:mul(math.min(addForce, 0.5)+(deadmanAdditionalForce[gi:section()] or 0))
		--dir:mul(0.5)
		self.force:add(dir)
		if self.a.ps:get_element_by_bone_name(deadmanMovingBone) then
			self.a.ps:get_element_by_bone_name(deadmanMovingBone):apply_force(self.force.x,self.force.y,self.force.z)
		elseif self.a.ps:get_element_by_bone_name(deadmanMovingBone2) then
			self.a.ps:get_element_by_bone_name(deadmanMovingBone2):apply_force(self.force.x,self.force.y,self.force.z)
		else
		end
	end
	
	-- уф! дотащили... всем спасибо, все свободны...
	if self.a.drop_lvid and self.a.drop_lvid==npc:level_vertex_id() then
		deadmansidsuses[self.a.choosed_deadman] = (deadmansidsuses[self.a.choosed_deadman] or 0) +1
		deadmansMoversIds[self.a.choosed_deadman]=nil
		self.a.choosed_deadman=nil
		self.a.reached=nil
		self.a.captures=nil
	end
end

function action_moving_deadman:finalize ()

	self.object:set_movement_type(move.walk)
	self.object:set_mental_state(anim.free)
	self.object:set_body_state(move.standing)
	self.object:movement_enabled(true)

	local gi = self.a.choosed_deadman and level.object_by_id(self.a.choosed_deadman)
	-- если уже задолбало дергать труп, а он застрял (дергаем 5 раз), то нафиг его
	if not gi or self.a.captures==6 or self.a.go_time_end<time_global() then
		if self.a.choosed_deadman then
			deadmansMoversIds[self.a.choosed_deadman]=nil
			self.a.choosed_deadman=nil
		end
		self.a.reached=nil
		self.a.captures=nil
	end
	action_base.finalize (self)
end

local npcDemoItemsCountMax = 3
npcItems = {}
npcItemsGived = {}
local npcItemsAvaliable = {}
local npcItemsNotAvaliableForSid = {
 	["guitar_a"] = true,
 	["harmonica_a"] = true,
}
local npcItemsAvaliableWithHemlet = {
-- 	["device_pda"] = true,
 	
 	["guitar_a"] = false,
 	["harmonica_a"] = false,
 	
 	["bread"] = false,
 	["sandwich"] = false,
 	["sweetness"] = false,
 	["kolbasa"] = false,
 	
 	["sigaret"] = false,
-- 	["cigara"] = false,
 	
 	["vodka"] = false,
 	["energy_drink"] = false,
 	["beer_a"] = false,
 	["flaska"] = false,
}
for k,v in pairs(npcItemsAvaliableWithHemlet) do
	table.insert(npcItemsAvaliable, k)
end

artsToAttachable = {
	["af_medusa"]					= "m",--
	["af_cristall_flower"]			= "cf",--
	["af_vyvert"]					= "v",--
	["af_gravi"]					= "g",--
	["af_gold_fish"]				= "gf",--
	["af_green"]					= "gr",--
	["af_drops"]					= "d",--
	["af_fireball"]					= "f",--
	["af_cristall"]					= "c",--
	["af_black_cristall"]			= "bc",--
	["af_blood"]					= "b",--
	["af_mincer_meat"]				= "mm",--
	["af_soul"]						= "s",--
	["gold_art"]					= "ga",--
	["af_electra_sparkler"]			= "es",--
	["af_electra_flash"]			= "ef",--
	["af_electra_moonlight"]		= "em",--
	["af_electro_crystal_thorn"]	= "ect",--
	["af_eye_voron"]				= "ev",--
	["af_ameba_slime"]				= "as",--
	["af_ameba_slug"]				= "asg",--
	["af_ameba_mica"]				= "am",--
	["af_rusty_thorn"]				= "rt",--
	["af_rusty_kristall"]			= "rk",--
	["af_rusty_sea_urchin"]			= "rsu",--
	["af_fuzz_kolobok"]				= "fk",--
	["af_dummy_dummy"]				= "dd",--
	["af_dummy_spring"]				= "ds",--
	["af_dummy_battery"]			= "db",--
	["af_dummy_pellicle"]			= "dp",--+++
	["af_dummy_glassbeads"]			= "dg",--
	["af_dummy_spring_red"]			= "dsr",--
	["af_dummy_battery_red"]		= "dbr",--
	["af_dummy_pellicle_red"]		= "dpr",--++
	["af_caterpillar"]				= "cp",--
	["af_armor_1"]					= "a1",--++
	["af_armor_2"]					= "a2",--++
	["af_armor_3"]					= "a3",--++
	["af_armor_4"]					= "a4",--++
	["af_babka_1"]					= "b1",--
	["af_babka_2"]					= "b2",--
	["af_babka_3"]					= "b3",--
	["af_babka_4"]					= "b4",--??
	["af_cry_1"]					= "c1",--
	["af_cry_2"]					= "c2",--
	["af_cry_3"]					= "c3",--
	["af_dik_1"]					= "d1",--oo
	["af_dik_2"]					= "d2",--oo
	["af_dik_3"]					= "d3",--oo
	["af_dik_4"]					= "d4",--oo
	["af_kol_1"]					= "k1",--
	["af_kol_2"]					= "k2",--
	["af_kol_3"]					= "k3",--
	["af_kol_4"]					= "k4",--
	["af_pudd_1"]					= "p1",--
	["af_pudd_2"]					= "p2",--
	["af_pudd_3"]					= "p3",--
	["af_pudd_4"]					= "p4",--
	["af_simbion"]					= "smb",--
	["af_spirit_1"]					= "s1",--
	["af_spirit_2"]					= "s2",--
	["af_spirit_3"]					= "s3",--
	["af_spirit_4"]					= "s4",--
	["af_spirit_pes"]				= "sp",--
	["af_buliz"]					= "bl",--
	["af_part_monolit"]				= "pm",--
	["af_part_monolit_pes"]			= "pmp",--
	["af_part_monolit1"]			= "pm1",--
	["af_part_monolit2"]			= "pm2",--
	["af_water_flower"]				= "wf",--
	["af_water_flower1"]			= "wf1",--
	["af_spiral"]					= "sprl",--
	["af_arhara_globus"]			= "ag",--
	["af_acumm"]					= "ac",--
}
attachableToArts = {}
for k,v in pairs(artsToAttachable) do
	attachableToArts["aa_"..v] = k
end

npcArtsToAttachable = {}
for k,v in pairs(artsToAttachable) do
	npcArtsToAttachable[k] = {"aa_"..v, "look_art_aa_"..v}
end

npcArtsAttachableToState = {}
for k,v in pairs(npcArtsToAttachable) do
	npcArtsAttachableToState[v[1]] = v[2]
end

local undirected = { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "checkpda", "eat_vodka", 
			"eat_energy", "eat_bread", "kurit_cigara", "eat_sandwich", "beer_a", "sweetness", "flaska", "kurit", "trans"}
for artsAttachable, state in pairs(npcArtsAttachableToState) do 
	table_insert(undirected, state)
end

local directed_art_attach = { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", 
			"eat_energy", "eat_bread", "kurit_cigara", "eat_sandwich", "beer_a", "sweetness", "flaska", "kurit", "trans"}
for artsAttachable, state in pairs(npcArtsAttachableToState) do 
	table_insert(directed_art_attach, state)
end
local avail_state = {
	idle =
		{ directed = directed_art_attach, 
		undirected = undirected},
	pre_harmonica =
		{ directed = { "wait_harmonica"},
		undirected = undirected},
	harmonica =
		{ directed = { "play_harmonica"},
		undirected = undirected},
	post_harmonica =
		{ directed = { "wait_harmonica"},
		undirected = undirected},
	pre_guitar =
		{ directed = { "wait_guitar"},
		undirected = undirected},
	guitar =
		{ directed = { "play_guitar"},
		undirected = undirected},
	post_guitar =
		{ directed = { "wait_guitar"},
		undirected = undirected},
	story =
		{ directed	= { "declarate", "trans"},
		undirected = undirected},
	post_story =
		{ directed	= { "declarate", "trans"},
		undirected = undirected},
	pre_joke =
		{ directed	= { "declarate", "trans"},
		undirected = undirected},
	joke =
		{ directed	= { "declarate", "trans"},
		undirected = undirected},
	post_joke =
		{ directed	= { "declarate", "trans"},
		undirected = undirected}}

local state_weight = {
	wait = 40, sit = 40, sit_ass = 40, sit_knee = 40, declarate = 30,
	eat_kolbasa = 10, flaska = 10, sweetness = 10, beer_a = 10, kurit_cigara = 10, eat_sandwich = 10, checkpda = 7, eat_vodka = 10, 
	eat_energy = 10, eat_bread = 10, kurit = 10, trans = 40,
	play_harmonica = 20, play_guitar = 20, play_joke = 20, play_story = 20, wait_harmonica = 100, wait_guitar = 100
}
for artsAttachable, state in pairs(npcArtsAttachableToState) do 
	state_weight[state] = 10--000000
end

								
local avail_sound = {
	idle = { directed	= "idle", undirected="idle"},
	pre_harmonica		= { directed = "pre_harmonica",		undirected = ""},
	harmonica		= { directed = "play_harmonica",	undirected = ""},
	post_harmonica		= { directed = "",			undirected = "reac_harmonica"},
	pre_guitar		= { directed = "pre_guitar",		undirected = ""},
	guitar			= { directed = "play_guitar",		undirected = ""},
	post_guitar		= { directed = "",			undirected = "reac_guitar"},
	story			= { directed = "play_story",		undirected = ""},
	post_story		= { directed = "",			undirected = "reac_story"},
	pre_joke		= { directed = "pre_joke",		undirected = ""},
	joke			= { directed = "play_joke",		undirected = ""},
	post_joke		= { directed = "",			undirected = "reac_joke"}}

	
---------------------------- выдача временных предметов неписям -------------------------------

function giveNpcDemoItem(npc, itemSection)
	if npc and itemSection then
		local npcId = npc:id()
		local npcGV = npc:game_vertex_id()
		local npcLV = npc:level_vertex_id()
		local npcPos = npc:position()
		if not npcItems[npcId] then
			npcItems[npcId] = {}
		end
		
		local sobj = alife():create(itemSection, npcPos, npcLV, npcGV, npcId)
		if sobj then
			npcItems[npcId][itemSection] = 3 -- выдали
		else
			npcItems[npcId][itemSection] = nil -- забыли нафиг
		end
	end
end

function giveNpcDemoItems(npc)
	if npc then
		local npcId = npc:id()
		local npcSid = npc:story_id()
		
		if npcItemsGived[npcId] then
			return
		end
		
		npcItemsGived[npcId] = true
		local notProcessed = not npcItems[npcId]
		if notProcessed then
			npcItems[npcId] = {}
		end		
		for i = 1, #npcItemsAvaliable do
			local obj = npc:object(npcItemsAvaliable[i])
			if obj then
				local sobj = alife():object(obj:id())
				if sobj then
					npcItems[npcId][npcItemsAvaliable[i]] = 1
				end
			end
		end

		local visual = sol_utils.getVisual(npc, true)
		local isVisualWithHemlet = visualWithHemlet[visual]
		
		-- выдаём то, что выдавалось ранее
		local npcDemoItemsCount = npcDemoItemsCountMax
		for k,v in pairs(npcItems[npcId]) do
			if v == 2 then
				giveNpcDemoItem(npc, k)
				npcDemoItemsCount = npcDemoItemsCount - 1
			end
		end
		
		-- если только в первый раз
		if not notProcessed then
			-- пять попыток выдать предметы
			local itemSection
			for i = 1, npcDemoItemsCount, 1 do
				local try = 0
				repeat
					itemSection = npcItemsAvaliable[math.random(1, #npcItemsAvaliable)]
					try = try + 1
				until try > #npcItemsAvaliable
					or npcItems[npcId][itemSection] == nil
						and (not isVisualWithHemlet or npcItemsAvaliableWithHemlet[itemSection])
						and (npcSid == 4294967296 or not npcItemsNotAvaliableForSid[itemSection])
			
				if npcItems[npcId][itemSection] == nil
					and (not isVisualWithHemlet or npcItemsAvaliableWithHemlet[itemSection])
					and (npcSid == 4294967296 or not npcItemsNotAvaliableForSid[itemSection])
				then
					giveNpcDemoItem(npc, itemSection)
				end
			end
		end

		-- выдаём псевдоарты
		for k,v in pairs(npcArtsToAttachable) do
			if npc:object(k) then
				giveNpcDemoItem(npc, v[1])
			end
		end
	end
end

function removeNpcDemoItems(npc)
	if npc then
		local npcId = npc:id()
		npcItemsGived[npcId] = false
		if npcItems[npcId] then
			for k,v in pairs(npcItems[npcId]) do
				if v == 3 then -- если не было и выдали
					local obj = npc:object(k)
					if obj then
						local sobj = alife():object(obj:id())
						if sobj then
							alife():release(sobj, true)
						end
						
						--о псевдоартах нужно забыть
						if attachableToArts[k] then
							npcItems[npcId][k] = nil
						else
							npcItems[npcId][k] = 2 -- было выбрано чтобы повторить потом
						end
					end
				end
			end
		end
	end
end
---------------------------- выдача временных предметов неписям -------------------------------	

class "CKampManager"
function CKampManager:__init(path, radius)
	self.kamp_name = path
	self.radius = radius
	self.patrol = patrol(path)
	self.center = self.patrol:level_vertex_id(0)
	self.position = {}
	local vertex, vertexUsed, vertexUsed2, tmpVertex
	local pos, pos2, dir, dir2
	local center_pos = level.vertex_position(self.center)
	local vertexDisabled = {}
	if radius > 0.5 then
		vertexDisabled[self.center] = true
	end
	for i = 1, #positionTemplate do
		dir = vector():set(positionTemplate[i][1], positionTemplate[i][2], positionTemplate[i][3])
		vertex = level.vertex_in_direction(self.center, dir, dir:magnitude() * radius)
			-- проверяем на дубликаты вертексов (был ли ранее вертекс отмечен как занятый)
			pos = level.vertex_position(vertex)
			vertexUsed = vertexDisabled[vertex] or radius >= 0.5 and pos:distance_to_sqr(center_pos) <= 0.5
			if not vertexUsed then
				for j = 1, #self.position do
					if vertex == self.position[j].vertex
						or
						radius >= 0.5
						and
						pos:distance_to_sqr(level.vertex_position(self.position[j].vertex)) <= 0.5
					then
						vertexUsed = true
						vertexDisabled[vertex] = true
						break
					end
				end
			end
			
			if not vertexUsed then
				local vrtx, vrtx_pos
				
				-- Где то здесь распарсим патрульный путь и проверим на запретные вертексы
				-- 0 вершина - центр лагеря.
				-- 1 флаг - сектор занят, в поинте можно сидеть.
				-- 2 флаг - сектор занят, в поинте нельзя сидеть.
				for k = 1, self.patrol:count() - 1 do
					-- если есть 1 или 2 флажок - отметить сектор как занятый
					if self.patrol:flag(k,1) or
					   self.patrol:flag(k,2)
					then
						vrtx = self.patrol:level_vertex_id(k)
						vrtx_pos = level.vertex_position(vrtx)
						-- отметить сектор как занятый
						if vrtx == vertex or vrtx_pos:distance_to_sqr(pos) <= 0.5 then
							vertexUsed = true
							vertexDisabled[vrtx] = true
							break
						end
					end
				end
			end
			
			if vertexUsed then
				-- попытка найти свободный вертекс рядом
				for l = 1, 5 do
					for j = 1, #positionTemplate do
						dir2 = vector():set(positionTemplate[j][1], positionTemplate[j][2], positionTemplate[j][3])
						tmpVertex = level.vertex_in_direction(vertex, dir2, dir:magnitude()+math.random()+l/2)
						pos2 = level.vertex_position(tmpVertex)
						vertexUsed2 = vertexDisabled[tmpVertex] or radius >= 0.5 and pos2:distance_to_sqr(center_pos) <= 0.5
						if not vertexUsed2 then
							for j2 = 1, #self.position do
								if tmpVertex == self.position[j2].vertex
									or
									radius >= 0.5
									and
									pos2:distance_to_sqr(level.vertex_position(self.position[j2].vertex)) <= 0.5
								then
									vertexUsed2 = true
									vertexDisabled[tmpVertex] = true
									break
								end
							end
							
							if not vertexUsed2 then
								local vrtx, vrtx_pos
								
								-- Где то здесь распарсим патрульный путь и проверим на запретные вертексы
								-- 0 вершина - центр лагеря.
								-- 1 флаг - сектор занят, в поинте можно сидеть.
								-- 2 флаг - сектор занят, в поинте нельзя сидеть.
								for k = 1, self.patrol:count() - 1 do
									-- если есть 1 или 2 флажок - отметить сектор как занятый
									if self.patrol:flag(k,1) or
										self.patrol:flag(k,2)
									then
										vrtx = self.patrol:level_vertex_id(k)
										vrtx_pos = level.vertex_position(vrtx)
										
										if vrtx == tmpVertex or vrtx_pos:distance_to_sqr(pos2) <= 0.5 then
											vertexUsed2 = true
											vertexDisabled[vrtx] = true
											break
										end
									end
								end
							end
							
							if not vertexUsed2 then
								vertex = tmpVertex
								vertexUsed = false
								break
							end
						end
					end
					if not vertexUsed then
						break
					end
				end
			end
			
			if not vertexUsed then
				vertexDisabled[vertex] = true
				table_insert(self.position, {vertex = vertex, used = nil})
			end
	end

	
	self.npc = {}
	self.population = 0
	self.kamp_state = "idle"
	
	self.timeout = {	-- Таблица таймаутов по состоянию. Если состояние установилось, то некоторое время оно не может быт изменено.						
		idle		= { min = 30000 },
		pre_harmonica	= { min = 3000 },
		harmonica	= { min = 5000, soundstart = true },
		post_harmonica	= { min = 3000 },
		pre_guitar	= { min = 3000 },
		guitar		= { min = 5000, soundstart = true },
		post_guitar	= { min = 3000 },
		story		= { min = 1000, soundstart = true },
		post_story	= { min = 3000 },
		pre_joke	= { min = 3000 },
		joke		= { min = 5000, soundstart = true },
		post_joke	= { min = 3000 }}

	self.kamp_states = {	-- Таблица глобальных состояний лагеря.
		idle		= true,		pre_harmonica	= false,	harmonica	= false,
		post_harmonica	= false,	pre_guitar	= false,	guitar		= false,
		post_guitar	= false,
		story		= false,	post_story	= false,
		pre_joke	= true,		joke		= true,		post_joke	= true}

	-- Таблица допустимых переходов между состояниями с вероятностями.
	self.trans_kamp = {
		idle		= { idle = 50, pre_harmonica = 30, pre_guitar = 30, story = 20, pre_joke = 20 }, 
		pre_harmonica	= { harmonica = 100 }, 
		harmonica	= { post_harmonica = 100 }, 
		post_harmonica	= { idle = 70, harmonica = 30 },
		pre_guitar	= { guitar = 100 }, 
		guitar		= { post_guitar = 100 }, 
		post_guitar	= { idle = 70, guitar = 30 },
		story		= { post_story = 100 }, 
		post_story	= { idle = 100 },
		pre_joke	= { joke = 100 }, 
		joke		= { post_joke = 100 }, 
		post_joke	= { idle = 100 }}

	self.director = nil	-- Хранилище для режиссера лагеря. Режиссерем является сталкер, затеявший необычное поведение
end

function CKampManager:selectPosition(npc)
	local npc_id = npc:id()
	local npc_pos = npc:position()
	-- создаем список доступных позиций
	local table_insert = table_insert
	local free_nearest_alone = {}
	local nearest_k, nearest_dist, dist
	local c_pos = level.vertex_position(self.center)
	for k,v in pairs(self.position) do
		if v.used == nil then
			local current_pos = level.vertex_position(v.vertex)
			local dir = vector():sub( level.vertex_position( v.vertex ), c_pos )
			local alone_dist = 0
			for k2,v2 in pairs(self.position) do
				if v2.used then
					local dir2 = vector():sub( level.vertex_position( v2.vertex ), c_pos )
					local yaw_to_used = math.max(0.1, math.abs(yaw(dir, dir2)))
					alone_dist = alone_dist --+ dist2 - 1 / dist2
				end
			end
			dist = current_pos:distance_to_sqr(npc_pos)
			local delta = math.abs(self.radius - current_pos:distance_to(c_pos))
			alone_dist = alone_dist + sech(delta)*5 + sech(dist) + current_pos:distance_to(c_pos)/10
			free_nearest_alone[k] = {npc_dist = dist, alone_dist = alone_dist}
		end
	end

	local nearest_alone_position, nearest_alone_value
	for k,v in pairs(free_nearest_alone) do
		if nearest_alone_position == nil or nearest_alone_value < v.alone_dist then
			nearest_alone_position = k
			nearest_alone_value = v.alone_dist
		end
	end

	if nearest_alone_position then
		self.position[nearest_alone_position].used = npc_id
		self.npc[npc_id].position = nearest_alone_position
	end
end
function CKampManager:getDestVertex(npc_id, radius)
	if npc_id == nil then return nil end
	if self.npc == nil or self.npc[npc_id] == nil then return nil end
	if self.npc[npc_id].position == nil then
		abort("CKampManager:getDestVertex(npc_id, radius) get dest Vertex: nil [%s]", npc_id)
		return nil
	end
	
	local position = self.position[self.npc[npc_id].position]
	if position.vertex ~= nil then
		return position.vertex
	end
	-- высчитываем вертех по направлению
   	local pp = level.vertex_in_direction(self.center, self.position[self.npc[npc_id].position].dir, radius)
	return pp		
end
function CKampManager:proceedState(npc)
	-- Проверка на таймаут
	local npc_id = npc:id()
	if self.npc == nil or self.npc[npc_id] == nil then return end
	local active_sound_count = npc:active_sound_count()
	if self.npc[npc_id].need_sound_begin == true then
		if active_sound_count == 0 then
			return
		else			
			self.npc[npc_id].need_sound_begin = false
		end
	end
	if self.begin ~= nil and
	   time_global() - self.begin < self.timeout[self.kamp_state].min
	then
		return
	end

	-- Если режиссер не закончил говорить - ждем конца фразы.
	if active_sound_count > 0 then
		return
	end
	-- В случае с историей переход обрабатывается отдельно
	if self.kamp_state == "post_story" then
		if self.story_last < self.story_max - 1 then
			self.npc[npc_id].begin = nil
			self.npc[npc_id].need_sound_begin = true
			self.director = npc_id
			self.kamp_state = "story"
			self.begin = time_global()
			for kk,vv in pairs(self.npc) do
				vv.new = true
			end		
			return
		else
			self.selected_story = nil
		end
	end
	-- Определяются допустимые в данный момент переходы.
	local temp = {}
	local max_rnd = 0
	for k,v in pairs(self.trans_kamp[self.kamp_state]) do		
		-- Определяются допустимые состояния для лагеря.
		if self.kamp_states[k] == true then
			temp[k] = v
			max_rnd = max_rnd + v
		end
	end
	-- Осуществляется рандомный взвешенный переход.
	if max_rnd == 0 then
		-- Если переходить некуда - переходим в айдл
		temp["idle"] = 100
		max_rnd = 100
	end
	local math_random = math.random
	local p = math_random(0,max_rnd)
	local dep
	for k,v in pairs(temp) do
		p = p - v
		if p <= 0 then
			if k == "idle" then
				self.director = nil
				if self.kamp_state ~= "idle" then
					self.npc[npc_id].begin = nil
				end
			else
				self.npc[npc_id].begin = nil
				if self.timeout[k].soundstart == true then
					self.npc[npc_id].need_sound_begin = true
				end
				self.director = npc_id
				self.censor = nil
			end			
			self.kamp_state = k
			self.begin = time_global()
			-- Меняем таймаут для истории
			if k == "post_story" then
				dep = sound_theme.theme[self.selected_story].depence[self.story_last]
				if dep and dep.min and dep.max then
					self.timeout["post_story"].min = math_random(dep.min, dep.max)*1000
				end
			end
			for kk,vv in pairs(self.npc) do
				vv.new = true
			end
			return
		end
	end
end
function CKampManager:proceedRole(npc, director)
	-- Определить список доступных анимаций по состоянию лагеря.
	-- определить список доступных анимаций по наличию предметов
	-- выбрать одну из них (то же самое со звуком).
	local sound = ""
	local state = ""
	local npc_id = npc:id()
	if self.npc == nil or self.npc[npc_id] == nil then return nil, nil end	
	if self.npc[npc_id].begin == nil or
	   time_global() - self.npc[npc_id].begin >= self.npc[npc_id].state_idle
	then
		local states
		if director then
			states = avail_state[self.kamp_state].directed
			sound = avail_sound[self.kamp_state].directed
		else
			states = avail_state[self.kamp_state].undirected
			sound = avail_sound[self.kamp_state].undirected
		end
		-- Выбирать новое состояние только раз в какое то время.
		local temp = {}
		local table_insert = table_insert
		local weightTotal = 0
		for k,v in pairs(states) do
			if self.npc[npc_id].states[v] == true then
				temp[v] = state_weight[v]
				weightTotal = weightTotal + state_weight[v]
			end
		end
		
		-- Если мы решили говорить историю, надо выбрать какую именно говорить.
		if sound == "play_story" and self.selected_story == nil and db.story_by_id[npc_id] ~= nil then
			local story_num = #db.story_by_id[npc_id]
			if story_num > 0 then
				self.selected_story = db.story_by_id[npc_id][math.random(story_num)]
			end			
		end

		self.npc[npc_id].begin = time_global()

		local stateWeightSelected = math.random(0, weightTotal)
		local stateWeightCount = 0
		for s, w in pairs(temp) do
			stateWeightCount = stateWeightCount + w
			if stateWeightCount >= stateWeightSelected then
				state = s
				break
			end
		end
		
		
		self.npc[npc_id].state_selected = state
		self.npc[npc_id].state_idle = math.random(15000,20000)		
	else
		if director then
			sound = avail_sound[self.kamp_state].directed
		else
			sound = avail_sound[self.kamp_state].undirected
		end
		state = self.npc[npc_id].state_selected	
	end
	return state, sound
end
function CKampManager:updateNpc(npc,st)
	-- Проверка что сталкер может делать, а что нет.
	self:checkNpcAbility(npc,st)
	-- Просим лагерь выбрать текущее состояние. Менять состояние лагеря
	-- имеет право только режиссер.
	local npc_id = npc:id()
	if self.npc == nil or self.npc[npc_id] == nil then return nil, nil, nil end		
	local director = self.director == nil or self.director == npc_id
	if director	then
		self:proceedState(npc)
	end
	-- Говорим чудаку выбрать себе состояние для текущего состояния лагеря.
	local state, sound = self:proceedRole(npc, director)
	
	local substate = nil
	if state == "wait_harmonica" then
		if sound == "pre_harmonica" and self.npc[npc_id].new == true then
			xr_sound.set_sound_play(npc, "intro_music", math.random(2000,3000))
			self.npc[npc_id].new = false
		end
		state = "harmonica"
		kamp_stalkers[npc_id] = false
	elseif state == "play_harmonica" then
		state = "harmonica"
		substate = 1
		kamp_stalkers[npc_id] = false
	elseif state == "wait_guitar" then
		if sound == "pre_guitar" and self.npc[npc_id].new == true then
			xr_sound.set_sound_play(npc, "intro_music", math.random(2000,3000))
			self.npc[npc_id].new = false
		end
		state = "guitar"
		kamp_stalkers[npc_id] = false
	elseif state == "play_guitar" then
		state = "guitar"
		substate = 1
		kamp_stalkers[npc_id] = false
	elseif state == "declarate" then
		if self.npc[npc_id].new == true then
			if sound == "pre_joke" then
				xr_sound.set_sound_play(npc, "intro_joke", math.random(2000,3000))
			elseif sound == "play_joke" then
				xr_sound.set_sound_play(npc, "joke", math.random(2000,3000))
			elseif sound == "play_story" then
				xr_sound.set_sound_play(npc, self.selected_story)
				self.story_last, self.story_max = xr_sound.get_last_IDS(npc, self.selected_story)
				if self.story_last==nil then
					self.story_last=0
					self.story_max=1
					xr_sound.set_sound_play(npc, "threat_back", math.random(1000,2000))
					--- dirty hack
					self.kamp_state="idle"
					self.forbiddendirector=self.director
					self.director=nil
				end
			end
			self.npc[npc_id].new = false
		end

		if npc:character_community() == "monolith" then
			local t = math.mod(npc_id, 2)
			if t == 0 then
				state = "trans_0"
			else
				state = "trans_1"
			end
		elseif npc:character_community() == "zombied" then
			state = "trans_zombied"
		else
			local t = math.mod(npc_id, 3)
			if t == 0 then
				state = "sit"
			elseif t == 1 then
				state = "sit_ass"
			else
				state = "sit_knee"
			end
		end
		kamp_stalkers[npc_id] = false
	elseif state == "trans" then
		if npc:character_community() == "monolith" then
			local t = math.mod(npc_id, 2)
			if t == 0 then
				state = "trans_0"
			else
				state = "trans_1"
			end
		elseif npc:character_community() == "zombied" then
			state = "trans_zombied"
		end
		kamp_stalkers[npc_id] = false
	else
		kamp_stalkers[npc_id] = true
	end
	-- Выбор реальных звуков
	if sound == "idle" and state ~= "checkpda" then
		sound = "weather, state"
	elseif sound == "reac_guitar" then
		sound = "reac_music"
	elseif sound == "reac_harmonica" then
		sound = "reac_music"
	elseif sound == "reac_joke" then
		sound = ""	
		if self.npc[npc_id].new == true then
			if self.censor == nil then
				xr_sound.set_sound_play(npc, "reac_joke", math.random(2000,3000))
				self.censor = npc_id
			else
				xr_sound.set_sound_play(npc, "story_reac_laughter", math.random(100,300))
			end
			self.npc[npc_id].new = false
		end
	elseif sound == "reac_story" then
		sound = ""
		if self.npc[npc_id].new == true then
			local dep = sound_theme.theme[self.selected_story].depence[self.story_last+1]
			if dep then
				if dep.type == "all" then
					xr_sound.set_sound_play(npc, dep.theme, math.random(100,300))
				else
					sound = dep.theme
				end
			end
		end
	elseif sound == "reac_story" then
		sound = ""
	else
		sound = ""
	end
	return state, sound, substate
end

function CKampManager:getNpcStateSelected(npc,st)
	return self.npc[npc:id()].state_selected
end

function CKampManager:checkNpcAbility(npc,st)
	local npc_id = npc:id()
    if npc_id == nil then return end		
	if self.npc == nil or self.npc[npc_id] == nil then return end
	if npc:character_community() ~= "monolith" and
	   npc:character_community() ~= "zombied"
	then
		local visual = sol_utils.getVisual(npc, true)
		local isVisualWithHemlet = visualWithHemlet[visual]
		-- есть колбасу
		if not isVisualWithHemlet and npc:object("kolbasa") then
			self.npc[npc_id].states["eat_kolbasa"] = true
		else
			self.npc[npc_id].states["eat_kolbasa"] = false
		end
		-- проверить ПДА
		if npc:object("device_pda") then
			self.npc[npc_id].states["checkpda"] = true
		else
			self.npc[npc_id].states["checkpda"] = false
		end
		
		-- осмотреть арт
		for artAttachable, state in pairs(npcArtsAttachableToState) do
			if npc:object(artAttachable) then
				self.npc[npc_id].states[state] = true
			else
				self.npc[npc_id].states[state] = false
			end
		end
		
		-- пить водку
		if not isVisualWithHemlet and npc:object("vodka") then
			self.npc[npc_id].states["eat_vodka"] = true
		else
			self.npc[npc_id].states["eat_vodka"] = false
		end
		-- пить енергитический напиток
		if not isVisualWithHemlet and npc:object("energy_drink") then
			self.npc[npc_id].states["eat_energy"] = true
		else
			self.npc[npc_id].states["eat_energy"] = false
		end
		-- есть хлеб
		if not isVisualWithHemlet and npc:object("bread") then
			self.npc[npc_id].states["eat_bread"] = true
		else
			self.npc[npc_id].states["eat_bread"] = false
		end
-- курит
		if not isVisualWithHemlet and npc:object("sigaret") then
                 self.npc[npc_id].states["kurit"] = true
		  else
                self.npc[npc_id].states["kurit"] = false
		end
                -- пить из фляжки
		if not isVisualWithHemlet and npc:object("flaska") then
			self.npc[npc_id].states["flaska"] = true
		else
			self.npc[npc_id].states["flaska"] = false
		end
                -- есть сладость
		if not isVisualWithHemlet and npc:object("sweetness") then
			self.npc[npc_id].states["sweetness"] = true
		else
			self.npc[npc_id].states["sweetness"] = false
		end
                -- пить пиво
		if not isVisualWithHemlet and npc:object("beer_a") then
			self.npc[npc_id].states["beer_a"] = true
		else
			self.npc[npc_id].states["beer_a"] = false
		end
                -- курит сигару
		--[[if not isVisualWithHemlet and npc:object("cigara") then
                        self.npc[npc_id].states["kurit_cigara"] = true
		  else
                        self.npc[npc_id].states["kurit_cigara"] = false
		end]]
		-- есть бутерброд
		if not isVisualWithHemlet and npc:object("sandwich") then
			self.npc[npc_id].states["eat_sandwich"] = true
		else
			self.npc[npc_id].states["eat_sandwich"] = false
		end
		if st.no_play ~= true and not isVisualWithHemlet then
			-- играть на гармошке
			if npc:object("harmonica_a") then
				self.npc[npc_id].states["play_harmonica"] = true
				self.npc[npc_id].states["wait_harmonica"] = true
				self.kamp_states["pre_harmonica"] = true
				self.kamp_states["harmonica"] = true
				self.kamp_states["post_harmonica"] = true
			else
				self.npc[npc_id].states["play_harmonica"] = false
				self.npc[npc_id].states["wait_harmonica"] = false
				self.kamp_states["pre_harmonica"] = false
				self.kamp_states["harmonica"] = false
				self.kamp_states["post_harmonica"] = false
			end
			-- играть на гитаре
			if npc:object("guitar_a") then
				self.npc[npc_id].states["play_guitar"] = true
				self.npc[npc_id].states["wait_guitar"] = true
				self.kamp_states["pre_guitar"] = true
				self.kamp_states["guitar"] = true
				self.kamp_states["post_guitar"] = true
			else
				self.npc[npc_id].states["play_guitar"] = false
				self.npc[npc_id].states["wait_guitar"] = false
				self.kamp_states["pre_guitar"] = false
				self.kamp_states["guitar"] = false
				self.kamp_states["post_guitar"] = false
			end
		end
		-- анекдоты
		if self.population > 1 and st.no_declarate ~= true then
			self.kamp_states["pre_joke"] = true
			self.kamp_states["joke"] = true
			self.kamp_states["post_joke"] = true
		else
			self.kamp_states["pre_joke"] = false
			self.kamp_states["joke"] = false
			self.kamp_states["post_joke"] = false
		end	
	end
	
	-- Если чувак знает истории, надо добавить их к лагерю
	
	if self.population > 1 and db.story_by_id[npc_id] ~= nil and st.no_declarate ~= true then
		self.kamp_states["story"] = true
		self.kamp_states["post_story"] = true
	else
		self.kamp_states["story"] = false
		self.kamp_states["post_story"] = false	
	end
end
function CKampManager:addNpc(npc)
	local npc_id = npc:id()
	if self.npc[npc_id] ~= nil then
		return
	end
	
	if npc:character_community() == "monolith" or npc:character_community() == "zombied" then
		local states = {stand_wait = false, sit = false, sit_ass = false, sit_knee = false, declarate = false,
			eat_kolbasa = false, flaska = false, sweetness = false, beer_a = false, kurit_cigara = false, eat_sandwich = false, checkpda = false, eat_vodka = false, eat_energy = false, eat_bread = false, kurit = false, trans = true,
			play_harmonica = false, play_guitar = false, play_joke = false, play_story = false}
		for artsAttachable, state in pairs(npcArtsAttachableToState) do 
			states[state] = false
		end
		self.npc[npc_id] = {name = npc:name(), position = nil, current = nil, speak = 0, ["states"] = states}
	else
		local states = {stand_wait = true, sit = true, sit_ass = true, sit_knee = true, declarate = true,
			eat_kolbasa = false, flaska = false, sweetness = false, beer_a = false, kurit_cigara = false, eat_sandwich = false, checkpda = false, eat_vodka = false, eat_energy = false, eat_bread = false, kurit = false, trans = false,
			play_harmonica = false, play_guitar = false, play_joke = false, play_story = false}
		for artsAttachable, state in pairs(npcArtsAttachableToState) do 
			states[state] = true
		end
		self.npc[npc_id] = {name = npc:name(), position = nil, current = nil, speak = 0, ["states"] = states}
	end
	self:selectPosition(npc)	
	if db.story_by_id[npc_id] == nil then
		local char_ini1 = g_ini_file("scripts\\stories.ltx")
		xr_info.loadInfo(npc, char_ini1)
	end
	
	-- выдаём неписям всякое для показухи у костра
	giveNpcDemoItems(npc)
end

function CKampManager:removeNpc(npc)
	local npc_id = npc:id()
	if self.npc[npc_id] ~= nil then
		-- отбираем у непися показушное
		removeNpcDemoItems(npc)
		-- Если удаляем режиссера - необходимо форсированно перевести лагерь в идловое состояние.
		if self.director == npc_id then
			self.director = nil
			self.npc[npc_id].begin = nil
			self.censor = nil
			self.kamp_state = "idle"
			self.begin = time_global()
			for kk,vv in pairs(self.npc) do
				vv.new = true
			end
			xr_sound.set_sound(npc, nil)
			stop_play_sound(npc)
		end
		-- nv 071105 - prevent crash if "defend border from Monolith" skipped
		if self.npc[npc_id].position ~= nil then
			self.position[self.npc[npc_id].position].used = nil
		end
		self.npc[npc_id] = nil
          
	end
end

----------------------------------------------------------------------------------------------------------------------
--Kamp binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(object, ini, scheme, section, storage)
	local operators		= {}
	local properties	= {}

	local manager = object:motivation_action_manager()
	
	properties["kamp_end"]		= xr_evaluators_id.stohe_kamp_base + 1
	properties["on_position"]	= xr_evaluators_id.stohe_kamp_base + 2
	properties["contact"]		= xr_evaluators_id.stohe_meet_base + 1    

	properties["see_deadman"]	= xr_evaluators_id.stohe_kamp_base + 3
	properties["can_move_deadman"]	= xr_evaluators_id.stohe_kamp_base + 5
	properties["state_mgr_off"]	= xr_evaluators_id.state_mgr+3

	operators["go_position"]	= xr_actions_id.stohe_kamp_base + 1
	operators["wait"]		= xr_actions_id.stohe_kamp_base + 3
	
	operators["go_to_deadman"]		= xr_actions_id.stohe_kamp_base + 4
	operators["move_deadman"]		= xr_actions_id.stohe_kamp_base + 5

	-- Evaluators                                                                            
	manager:add_evaluator (properties["kamp_end"], 		this.evaluator_kamp_end		("kamp_end", storage, "kamp_end"))
	manager:add_evaluator (properties["on_position"],	this.evaluator_on_position	("kamp_on_position", storage, "kamp_on_position"))
	
	local comm = object:character_community()
	local name = object:name()
	local zombi = comm == "zombied" or comm == "trader" or comm == "arena_enemy"
		or name == "mil_stalker0012" or name == "yantar_ecolog_general"

	if zombi then
		manager:add_evaluator (properties["see_deadman"], property_evaluator_const(false))
		manager:add_evaluator (properties["can_move_deadman"], property_evaluator_const(false))
	else
		manager:add_evaluator (properties["see_deadman"],	this.evaluator_see_deadman	("see_deadman", storage, "see_deadman"))
		manager:add_evaluator (properties["can_move_deadman"],	this.evaluator_can_move_deadman	("can_move_deadman", storage, "can_move_deadman"))
	end
	-- Actions
	local action = this.action_wait (name,"action_kamp_wait", storage)
	action:add_precondition		(world_property(stalker_ids.property_alive, true))
	action:add_precondition		(world_property(stalker_ids.property_danger,false))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	action:add_precondition		(world_property(stalker_ids.property_anomaly,false))
	action:add_precondition 	(world_property(properties["see_deadman"], 	false))
	xr_motivator.addCommonPrecondition(action)
	action:add_precondition		(world_property(properties["on_position"], 	true))
	action:add_effect 		(world_property(properties["kamp_end"], 	true))
	manager:add_action (operators["wait"], action)
	xr_logic.subscribe_action_for_events(object, storage, action)
	
	action = this.action_go_position (name,"action_go_kamp", storage)
	action:add_precondition		(world_property(stalker_ids.property_alive, true))
	action:add_precondition		(world_property(stalker_ids.property_danger,false))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	action:add_precondition		(world_property(stalker_ids.property_anomaly,false))
	action:add_precondition 	(world_property(properties["see_deadman"], 	false))
	xr_motivator.addCommonPrecondition(action)
	action:add_precondition 	(world_property(properties["on_position"], 	false))
	action:add_effect 		(world_property(properties["on_position"], 	true))
	manager:add_action (operators["go_position"], action)
	
	-- видим труп - идем разбираться...
	action = this.action_go_to_deadman (name,"action_go_to_deadman", storage)
	action:add_precondition		(world_property(stalker_ids.property_alive, true))
	action:add_precondition		(world_property(stalker_ids.property_danger,false))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	action:add_precondition		(world_property(stalker_ids.property_anomaly,false))
	action:add_precondition 	(world_property(properties["see_deadman"], 	true))
	xr_motivator.addCommonPrecondition(action)
	action:add_precondition 	(world_property(properties["can_move_deadman"], 	false))
	action:add_precondition		(world_property(properties["kamp_end"],		false))
	action:add_effect 		(world_property(properties["can_move_deadman"], 	true))
	manager:add_action (operators["go_to_deadman"], action)

	--тащим труп подальше от тусовки
	action = this.action_moving_deadman (name,"action_moving_deadman", storage)
	action:add_precondition		(world_property(stalker_ids.property_alive, true))
	action:add_precondition		(world_property(stalker_ids.property_danger,false))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	action:add_precondition		(world_property(stalker_ids.property_anomaly,false))
	action:add_precondition 	(world_property(properties["see_deadman"], 	true))
	xr_motivator.addCommonPrecondition(action)
	action:add_precondition 	(world_property(properties["can_move_deadman"], 	true))
	action:add_precondition		(world_property(properties["kamp_end"],		false))
	action:add_effect 		(world_property(properties["see_deadman"], 	false))
	action:add_effect 		(world_property(properties["can_move_deadman"], 	false))
	manager:add_action (operators["move_deadman"], action)

	action = manager:action (xr_actions_id.alife)	
	action:add_precondition		(world_property(properties["kamp_end"],		true))

end
-- включение лагеря
function set_scheme(npc, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
	st.logic = xr_logic.cfg_get_switch_conditions(ini, section, npc)		
	st.center_point = utils.cfg_get_string(ini, section, "center_point", npc, true,  gulag_name)
	st.radius = utils.cfg_get_number(ini, section, "radius", npc, false, 2)
	if kamps[st.center_point] == nil then kamps[st.center_point] = CKampManager(st.center_point, st.radius) end
	kamps[st.center_point]:addNpc(npc)
	st.pos_vertex = nil
	st.def_state_moving = utils.cfg_get_string(ini, section, "def_state_moving", npc, false, "", "walk")
	st.no_declarate = utils.cfg_get_bool(ini, section, "no_declarate", npc, false)
	st.no_play = utils.cfg_get_bool(ini, section, "no_play", npc, false)
end