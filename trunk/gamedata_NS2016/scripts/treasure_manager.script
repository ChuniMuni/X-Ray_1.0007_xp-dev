-- solid_list основан на Linspiro Addon v1.1
local string_find = string.find
local table_insert = table.insert
local math_random = math.random
local string_format = string.format

function abort( ... ) _util.abort( "treasure_manager", ... ) end

local rare_list = {

 novice_section = {
 "wpn_toz34",
 "wpn_ak74",
 "wpn_m4super90",
 "scientific_outfit",
 "stalker_outfit_v3",
 "specops_outfit",
 "dolg_gaz_outfit_m1",
 "ammo_vog25p",
 "ammo_m209",
 "ammo_12x76_zhekan",
 "ammo_5.45x39_ap",
 "ammo_9x39_ap",
 "ammo_9x39_sp5",
 "mutant_flesh_eye",		
 "mutant_boar_leg",		
 "mutant_dog_tail",		  			
 "mutant_zombie_hand",		
 "mutant_face_tushkano",		
 "mutant_tail_cat",				   
 "mutant_spleen_rat",
 "af_medusa",
 "af_vyvert",
 "af_blood",
 "af_electra_sparkler",
 "af_rusty_thorn",
 "af_ameba_slime",
 "af_drops",      	
 "af_ameba_mica",
 "af_soul",
 "af_night_star",
 "af_electra_moonlight",
 "af_gravi",
 "af_cristall_flower",
 "af_mincer_meat",
 "af_electra_flash",
 "af_rusty_kristall",
 "af_ameba_slug",
 "af_fireball",
 "medkit_army"
  },

 experienced_section = {
 "ammo_7.62x54_ap",
 "ammo_7.62x54_7h14",
 "ammo_og-7b",
 "mutant_zombie_hand",
 "mutant_snork_leg",				
 "mutant_poltergeist_glas",				
 "mutant_fracture_hand", 
 "mutant_boar_leg",  
 "wpn_m16a2_sk1",
 "wpn_sg552_sk1",
 "wpn_wincheaster1300",
 "wpn_m4",
 "wpn_ppsh41_sk2",
 "military_outfit",
 "svoboda_heavy_outfit",
 "dolg_scientific_outfit",
 "freedom_scientific_outfit",
 "merc_scientific_outfit",
 "monolit_scientific_outfit",
 "nebo_scientific_outfit",
 "outfit_dolg_m1",
 "outfit_killer_m1",
 "af_rusty_sea_urchin",
 "af_ameba_mica",
 "af_soul",
 "af_night_star",
 "af_dummy_glassbeads",
 "af_dummy_pellicle",
 "af_dummy_battery",
 "af_dummy_dummy",
 "af_dummy_spring",
 "af_babka_1",
 "af_spirit_1",
 "medkit_army",
 "detonator",
 "bomba_small",
 },

 veteran_section = {
 "af_dummy_dummy",
 "af_spirit_1",        
 "af_spirit_2",       
 "af_cry_1",
 "af_babka_1",
 "af_pudd_1",
 "af_pudd_2",
 "af_dik_1",
 "af_kol_1",
 "af_armor_1",
 "af_armor_2",
 "af_dummy_dummy",
 "af_dummy_spring",
 "af_eye_voron",
 "ammo_og-7b",
 "ammo_vog25p",	
 "mutant_krovosos_jaw",		
 "mutant_burer_hand",
 "mutant_zombie_hand",	
 "mutant_hand_kontroler",			
 "mutant_psevdogigant_hand",			
 "mutant_chimera_kogot",
 "wpn_spas12",
 "wpn_vintorez",	
 "wpn_rpg7",
 "wpn_g36",
 "wpn_m1891_30_scope",
 "wpn_pkm",	
 "wpn_groza",
 "medkit_army",
 "detonator",
 "bomba_mina_n",
 "bomba"
 
 },

master_section = {
 "wpn_vintorez",
 "wpn_svu",
 "wpn_svd",
 "wpn_rpg7",
 "wpn_fn2000",	
 "mutant_krovosos_jaw",		
 "mutant_burer_hand",		
 "mutant_hand_kontroler",				
 "mutant_psevdogigant_hand",					
 "mutant_chimera_kogot",		
 "af_simbion",        
 "svoboda_exoskeleton",
 "monolit_exoskeleton",
 "nebo_exo_outfit",
 "exo_bandit_outfit",
 "exo_outfit",    
 "af_spirit_2",         
 "af_cry_2",
 "af_babka_2",
 "af_pudd_2",
 "af_babka_3",
 "af_dik_2",
 "af_kol_2",
 "af_kol_3",
 "af_armor_2", 
 "af_armor_3",
 "medkit_army",
 "medkit_scientic",
 "detonator",
 "bomba_mina_n",
 "bomba"
 }
}

local solid_list = {
 novice_section = {
 --Артефакты--
 "af_drops",
 "af_ameba_slime",
 "af_rusty_thorn",
 "af_electra_sparkler",
 "af_blood",
 "af_vyvert",
 "af_medusa",
 --Аммуниция--
 "grenade_rgd5",
 "ammo_12x76_zhekan",
 "ammo_9x19_pbp",
 "ammo_9x18_pmm",
 --Оружие--
 "wpn_mp5",
 "wpn_bm16",
 "wpn_fort",
 "wpn_pm",
 --Прочее--
 "bread",
 "bandage",
 "kolbasa",
 "medkit",
 "vodka",
 "sigaret",
 "conserva"
 },

experienced_section = {
--Артефакты--
 "af_cristall_flower",
 "af_gravi",
 "af_mincer_meat",
 "af_electra_flash",
 "af_rusty_kristall",
 "af_ameba_slug",
 "af_fireball",
 --Аммуниция--
 "grenade_rgd5",
 "grenade_gd-05",
 "grenade_f1",     
 "ammo_9x19_pbp",
 "ammo_9x18_pmm",
 "ammo_5.45x39_ap",
 "ammo_11.43x23_hydro",
 "ammo_5.56x45_ap",
 --Пушки--
 "wpn_mp5",
 "wpn_ak74u",
 "wpn_walther",
 --Прочее--
 "mutant_dog_tail",
 "mutant_boar_leg",
 "kolbasa",
 "medkit",
 "antirad",
 "energy_drink",
 "conserva",
 -- взрывчатка
 "detonator",
 "bomba_mina_n",
 "bomba_small",
 },

 veteran_section = {
 --Артефакты--
 "af_night_star",
 "af_gold_fish",
 "af_soul",
 "af_electra_moonlight",
 "af_rusty_sea_urchin",
 "af_ameba_mica",
 "af_cristall",
 --Аммуниция--
 "grenade_f1",
 "ammo_vog25",     
 "ammo_m209",
 "ammo_5.45x39_ap",
 "ammo_11.43x23_hydro",
 "ammo_9x39_ap",
 "ammo_5.56x45_ap",
 "ammo_12x76_dart",
 --Пушки--
 "wpn_beretta",
 "wpn_sig550",
 "wpn_toz34",
 "wpn_desert_eagle",
 --Прочее--
 "mutant_psevdodog_tail",
 "mutant_snork_leg",
 "medkit_army",
 "antirad",
 -- взрывчатка
 "detonator_2",
 "bomba_mina_n",
 "bomba"
 },

 master_section = {
 --Артефакты--
 "af_dummy_glassbeads",
 "af_dummy_pellicle",
 "af_dummy_battery",
 "af_dummy_dummy",
 "af_dummy_spring",
 "af_fuzz_kolobok",
 --Аммуниция--
 "ammo_m209",
 "ammo_vog25p",     
 "ammo_9x39_ap",
 "ammo_12x76_dart",
 "ammo_7.62x54_7h14",
 "ammo_9x39_sp5",
 "ammo_5.56x45_ap",
 --Пушки--
 "wpn_colt1911",
 "wpn_spas12",
 "wpn_l85",
 "wpn_lr300",
 "wpn_groza",
 --Прочее--
 "mutant_krovosos_jaw",
 "mutant_burer_hand",
 "medkit_army",
 "medkit_scientic",
 -- взрывчатка
 "detonator_2",
 "bomba_mina_b",
 "bomba_big",
 }
}


local force_offline = _G.force_offline
if not force_offline then 
	force_offline = {}
	_G.force_offline = force_offline
end


local treasure_manager = nil
local n_rank 

function parse_spawns(line)
	if line == nil then
		return {}
	end

	--' если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
	local t = se_respawn.parse_names(line)
	local n = table.getn(t)
		
	local ret_table = {}
	local k = 1

	while k <= n do
		local spawn = {}
		spawn.section = t[k]
		-- Проверяем что это не последняя запись
		if t[k+1] ~= nil then
			local p = tonumber(t[k+1])
			-- проверяем что вторым числом задана вероятность, а не другая секция спавну
			if p then
				-- забиваем число
				spawn.prob = p
				k = k + 2
			else
				-- забиваем дефолт 1
				spawn.prob = 1
				k = k + 1
			end
		else
			spawn.prob = 1
			k = k + 1
		end
		table.insert(ret_table, spawn)
	end
	return ret_table
end


class "CTreasure"


function CTreasure:__init()
	local ini = ini_file( "misc\\treasure_manager.ltx" )
	if ini and ini:section_exist( "list" ) then self.ini = ini
	else abort( "__init, invalid file treasure_manager.ltx (section [list] absent" )
	end

	local t = {}
	self.treasure_info = t

	local t_sid = {}
	self.treasure_by_target = t_sid

	local sim = alife()

	local tt, obj, r, k, v

	local actor = db.actor

	for i = 0, ini:line_count( "list" ) - 1 do
		r, k, v = ini:r_line( "list", i, "", "" )

		tt = { ["active"] = false, ["done"] = false }
		t[k] = tt

		-- читаем sid
		r = utils.cfg_get_number( ini, k, "target", nil, true )
		force_offline[r] = 2
		tt.target = r
		t_sid[r] = k	-- таблица соответствия sid-имя (идиотизм. основная по sid должна быть)

		tt.name		= utils.cfg_get_string( ini, k, "name", nil, true, "" )
		tt.description	= utils.cfg_get_string( ini, k, "description", nil, true, "" )

		r = utils.cfg_get_string( ini, k, "items", nil, true, "" )
		if r then tt.items = parse_spawns( r )
		else abort( "__init, invalid items list: %s (treasure_manager.ltx)", k )
		end

		r = parse_names( utils.cfg_get_string( ini, k, "community", nil, false, "", "stalker, bandit, dolg, freedom" ) )
		tt.community = {}
		for k, v in pairs( r ) do tt.community[v] = true end

		tt.condlist = xr_logic.parse_condlist( utils.cfg_get_string( ini, k, "condlist", nil, false, "", "" ), actor, "treasure_manager", "condlist"  )
	end
end


function CTreasure:use( npc )
	if not npc then return end

	local se_obj = alife():object( npc:id() )
	if se_obj.treasure_processed == true then return end
	if se_obj.cut_part then
		se_obj.treasure_processed = true
		return
	end
	se_obj.treasure_processed = true

	lootmoney.lootmoney( npc )

	-- если выбран редкий тип тайников, то снизим вероятность его выпадения
	if amk.load_variable( "option_treasure", 0 ) == 2 then
		if math.random( 100 ) < 97 then return end
	elseif math.random(100) < 90 then return
	end

	local t = {}
	local n = 0
	local p
	local com = npc:character_community()

	for k, v in pairs( self.treasure_info ) do

		if not ( v.done or v.active ) and v.community[com] then
			p = xr_logic.pick_section_from_condlist( db.actor, npc, v.condlist )
			if p and p ~= "" then
				p = tonumber( p )
				if p ~= 0 then
					table.insert( t, { ["k"] = k, ["p"] = p } )
					n = n + p
				end
			end
		end
	end

	if n ~= 0 then
		n = math.random( n )
		for i, v in ipairs( t ) do
			if n < v.p then n = n - v.p
			else
				self:give_treasure( v.k, npc )
				break
		end	end
	end
end


--' Сохранение ???? похоже, что не используется
function CTreasure:check()	--' Проверка тайников
	for k,v in pairs(self.treasure_info) do self:give_treasure(k) end	--' Выдать тайник
end

--' Выдача тайника
function CTreasure:give_treasure(k, npc)
	local v = self.treasure_info[k]
	local obj = alife():story_object(v.target)
	if obj then
		news_manager.send_treasure(v.name)
		if npc then n_rank = ranks.get_obj_rank_name(npc)
		else
			local rank_list = {"novice", "experienced", "experienced", "veteran", "master"}
			n_rank = rank_list[math_random(5)]
		end

		--' Пометить на карте		
		local text = "%c[255,238,155,23]"..game.translate_string(v.name).."\\n".."%c[default]"..game.translate_string(v.description)
		level.map_add_object_spot_ser(obj.id, "treasure", text)

		-- проверка, какой тип тайника выбран
		-- если тайник не классический и не именной, то заменим содержимое
		if amk.load_variable("option_treasure", 0) ~= 0 and self:named_treasure(v) == false then
			v.items = self:give_item_list()
		end
		
		--' Сгенерить вещи
		for kk,vv in pairs(v.items) do
			if ammo_section[vv.section] == true then
				se_respawn.create_ammo(vv.section,	
						obj.position,
						obj.m_level_vertex_id,	
						obj.m_game_vertex_id,
						obj.id,
						vv.prob)
			else
				for i=1,vv.prob do
					alife():create(vv.section,
							obj.position,
							obj.m_level_vertex_id,	
							obj.m_game_vertex_id,
							obj.id)
				end
			end
		end
		
		--' Пометим тайник как выданный
		self.treasure_info[k].active = true
		self.treasure_info[k].done = true
		-- Отправим тайник в оффлайн
		local sim = alife()
		if sim and obj.online then
			sim:set_switch_online(obj.id, false)
			sim:set_switch_offline (obj.id, true)
			force_offline[obj.id] = 1 -- ставим в очередь на вывод в онлайн
		end
	end
end

--' Снимаем отметку с тайника
function CTreasure:treasure_empty(box, box_story_id)
	local t = self.treasure_info[self.treasure_by_target[box_story_id]]
	if t then t.active = false
	else return	-- это не мы положили
	end
	
	-- если тайник не именной, разрешим повторную выдачу
	if not self:named_treasure( t ) then t.done = false end
	level.map_remove_object_spot( box:id(), "treasure" )
end


--' Сохранение
function CTreasure:save(p)
	--' Сохраняем размер таблицы
	local size = 0
	for k,v in pairs(self.treasure_info) do
		size = size + 1
	end
	p:w_u16(size)
	for k,v in pairs(self.treasure_info) do
		p:w_u16(v.target)
		p:w_bool(v.active)
		p:w_bool(v.done)
	end
end
--' Загрузка
function CTreasure:load(p)
	local t = p:r_u16()
	for i = 1,t do
		local k = self.treasure_by_target[p:r_u16()]
		self.treasure_info[k].active = p:r_bool()
		self.treasure_info[k].done = p:r_bool()
	end
end

function CTreasure:give_item_list()
	local rank = 1
	local tabla = {}
	local i = math.random(1, 4)	-- сколько наименований предметов будет в тайнике
	local opt = amk.load_variable("option_treasure", 0)	-- считаем настройку пользователя

	for j = 1, i, 1 do
		local cnt = 0
		local spawn = {}
		-- определим, из какой секции брать предметы, и какие именно  
		if opt == 1 then spawn.section = solid_list[n_rank.."_section"][math.random(#solid_list[n_rank.."_section"])]
		else spawn.section = rare_list[n_rank.."_section"][math.random(#rare_list[n_rank.."_section"])]
		end	 

		-- установка кол-ва предметов в зависимости от секции  
		if ammo_section[spawn.section] == true then
			--local ini = system_ini()
			local num_in_box = getIniValueU32Simple(spawn.section, "box_size") --ini:r_u32(spawn.section, "box_size")
			local h = math.random(1, 5)
			cnt = math.random(1, h) * num_in_box	-- патроны выдаем не штуками, а пачками
		else
			local s = tostring(spawn.section)
			if string_find(s, "outfit") or string.find(s, "wpn") then cnt = 1
			elseif string_find(s, "addon") or string_find(s, "af_") or string_find(s, "mutant") then cnt = math.random(1,2)
			else cnt = math.random(1,5)
			end   
		end
  
	-- сохраняем инфу о текущем предмете
	spawn.prob = cnt
	table_insert(tabla, spawn)
	end
	return tabla
end

function CTreasure:named_treasure(v)
 -- проверка, является ли тайник именным. Если да, то его наполнение не меняется
 if   v.name == "agr_secret_0000_name" --Тайник Серого
   or v.name == "bar_secret_0011_name" --Тайник Арни
   or v.name == "esc_secret_0013_name" --Тайник Ворпала
   or v.name == "gar_secret_0002_name" --Вещи Гризли
   or v.name == "gar_secret_0011_name" --Склад группы Стрелка
   or v.name == "gar_secret_0021_name" --Рюкзак Дохляка
   or v.name == "pri_secret_0003_name" --Хабар Клыка
   or v.name == "pri_secret_0004_name" --Запасы лидера Свободы
   or v.name == "rad_secret_0000_name" --Клад Угрюмого
   or v.name == "rad_secret_0004_name" --Запас группы отчаянных
   or v.name == "ros_secret_0015_name" --Тайник Счастливчика
   or v.name == "ros_secret_0018_name" --Ящик с медикаментами
   or v.name == "val_secret_0028_name" --Тайник Борова
   or v.name == "x18_secret_0000_name" --Тайник Копченого
   or v.name == "yan_secret_0011_name" --Тайник учёного
   or v.name == "agr_krysyk_secret_name"
   or v.name == "val_krysyk_secret_name"
   or v.name == "mil_borov_secret_name"
   or v.name == "aver_arhara_secret_1" --Тайник Архары
   or v.name == "aver_arhara_secret_2" --Тайник Пилигрима
   or v.name == "aver_arhara_secret_3" --Тайник Отшельника
   or v.name == "aver_arhara_secret_4" --Тайник Звездочёта
   or v.name == "aver_arhara_secret_5" --Тайник Старика
   or v.name == "warlab_arhara_secret_1" --Тайник 
   or v.name == "warlab_arhara_secret_2" --Тайник 
   or v.name == "warlab_arhara_secret_3" --Тайник
   or v.name == "village_arhara_secret_1" --Тайник Михи
   or v.name == "village_arhara_secret_2" --Тайник местного
   or v.name == "village_arhara_secret_3" --рюкзак капитана
   or v.name == "village_arhara_secret_4" --Тайник лейтенанта
   or v.name == "generators_arhara_secret_1" --Рюкзак монолитовца
   or v.name == "generators_arhara_secret_2" --Тайник Земляка
   or v.name == "generators_arhara_secret_3" --Хабар охранника
   or v.name == "generators_arhara_secret_4" --Тайник Фрица
   or v.name == "generators_arhara_secret_5" --неизвестный тайник
   or v.name == "atp_arhara_secret_1" --Тайник матёрого разведчика
   or v.name == "atp_arhara_secret_2" --Заначка Шныры
   or v.name == "atp_arhara_secret_3" --Хабар Кита
   or v.name == "dead_city_secret_1" --Заначка беглеца
   or v.name == "dead_city_secret_2" --Вещи зомбированного
   or v.name == "dead_city_secret_3" --Нычка Обморока
   or v.name == "dead_city_secret_4" --Схрон старожила
   or v.name == "dead_city_secret_5" --Дедкины вещи
   or v.name == "zaton_secret_1" --Шмотки утопленника
   or v.name == "zaton_secret_2" --Кустарный тайник
   or v.name == "zaton_secret_3" --Хабар безумца
   or v.name == "zaton_secret_4" --Рюкзак Докера
   or v.name == "zaton_secret_5" --Скарб скалолаза
   or v.name == "zaton_secret_6" --Тайник ассенизатора
   or v.name == "zaton_secret_7" --Рюкзак трубочиста
   or v.name == "zaton_secret_8" --Заначка самоубийцы 
   or v.name == "esc_secret_0010_name" --Тайник с пивом
	then return true
	else return false
	end    
end

function get_treasure_manager()
	if treasure_manager == nil then treasure_manager = CTreasure() end
	return treasure_manager
end

function take_item_from_box( box, box_story_id )
	get_treasure_manager():treasure_empty( box, box_story_id )
end

function save(p)
	get_treasure_manager():save(p)
end
function load(p)
	get_treasure_manager():load(p)
end
function clear_treasure_manager()
	treasure_manager = nil
end

function CTreasure:dialog(npc)
	n_rank = ranks.get_obj_rank_name(npc)
	local avail = {}
	local tr_sum = 0
	for k,v in pairs(self.treasure_info) do
		if v.done == false and v.active == false and v.community[npc:character_community()] == true then
			local treasure_prob = xr_logic.pick_section_from_condlist(db.actor, npc, v.condlist)
			if treasure_prob == "" or treasure_prob == nil then treasure_prob = 0 end
			if tonumber(treasure_prob) >= 0 and v.community[npc:character_community()] == true
			  and v.active == false then
				if tonumber(treasure_prob) == 100 then self:give_treasure(k)
				else
					table.insert(avail, {k = k, prob = treasure_prob})
					tr_sum = tr_sum + treasure_prob
				end
			end
		end
	end
	if tr_sum == 0 then return end
	local tr_w = math.random(tr_sum)
	for k,v in pairs(avail) do
		tr_w = tr_w - v.prob
		if tr_w <= 0 then
			self:give_treasure(v.k)
			break
		end
	end
end
