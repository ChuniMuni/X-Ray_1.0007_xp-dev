-- Idler: файл из мода 'Народная солянка 2.0'. Адаптирован для мода 'Метки с хабаром 2.1.2' 30.09.2008 0:08:52
-- добавлена fenechka by TAG

local table_sort = table.sort
local table_remove = table.remove
local table_insert = table.insert
local math_floor = math.floor
local math_random = math.random
local math_sqrt = math.sqrt
local string_sub = string.sub
local string_find = string.find
local string_byte = string.byte
local string_char = string.char
local string_match = string.match
local string_len = string.len
local string_gsub = string.gsub
local string_rep = string.rep
local string_gfind = string.gfind
local string_format = string.format

----------------

local timers		--хранит реал-тайм таймеры
local timers_id_name = {}
local timers_name_id = {}
-- local g_timers={}	--хранит таймеры в игровом времени
local markers={}	--хранит маркеры на карте
local x_objs={}		--хранит ИДшники объектов
local timer_trigger=nil
local force_offline = _G.force_offline
if not force_offline then 
 force_offline = {}
 _G.force_offline = force_offline
end
convert_npc = force_offline
g_kick=false
oAmkLauncher = amkII_launcher.CAmkLauncher()
local StartTime
oau_watchdog = 0
oau_reason = ""
--переменные для типсов
pda_news = xr_sound.get_safe_sound_object([[device\pda\pda_news]])
pda_tips = xr_sound.get_safe_sound_object([[device\pda\pda_tip]])
pda_task = xr_sound.get_safe_sound_object([[device\pda\pda_objective]])

tips_icons = {
	default		={ 0,	658 },
	trader		={ 332, 893 },
	dolg		={ 0,	658 },
	freedom		={ 0,	658 },
	ecolog		={ 498, 0   },
	arena		={ 332, 141 },
	stalker		={ 0,	658 },
	krot		={ 332,	47  },
	barman		={ 332,	235 },
	wolf		={ 332,	940 },
	o_soznanie	={ 498,	893 },
	monolith	={ 0,	658 },
	saharov		={ 332,	470 },
	prizrak		={ 0,	658 },
	killer		={ 0,	658 },
	death		={ 0,	752 },
	gen_info	={ 0,	658 },
	trade		={ 0,	0   },
	uniq		={ 498,	47  }	--{ 498, 188}
}


--показываем типс
function send_tip(news_text, header, timeout, showtime, sender, sound) counterAdd("amk.send_tip")
	if news_text==nil then return end
	if header==nil then header=game.translate_string("st_tip") end
	if timeout == nil then timeout = 0 end
	if showtime == nil then showtime = 5 end
  
	local player
	if sound=="news" then player=pda_news
	elseif sound=="task" then player=pda_task
	else player=pda_tips
	end   
  
	--' Играем дефолтный звук
	player:play(db.actor, timeout, sound_object.s2d)
  
	if sender == nil then sender = "default" end
	local x = tips_icons[sender][1]
	local y = tips_icons[sender][2]
  
	local news_text = "%c[255,160,160,160]"..header.."\\n".."%c[default]"..news_text
	db.actor:give_game_news(news_text, "ui\\ui_iconsTotal", Frect():set(x,y,83,47), timeout*1000, showtime*1000)
	return true
end

function add_spot_on_map(obj_id,type,text) counterAdd("amk.add_spot_on_map")
	--возможные типы type смотри в ui\map_spots.xml 
	if obj_id then
		if text==nil then text=" " end
		-- Ставим метку на серверный объект чтобы её не пришлось обновлять
		level.map_add_object_spot_ser(obj_id, type, text)
		-- save_variable("x_marker_type_"..obj_id, type)
		-- save_variable("x_marker_text_"..obj_id, text)
	end
end

function remove_spot_from_map(obj_id,type) counterAdd("amk.remove_spot_from_map")
	if obj_id and level.map_has_object_spot(obj_id, type)~= 0 then
		level.map_remove_object_spot(obj_id, type)
		-- del_variable("x_marker_type_"..obj_id)
		-- del_variable("x_marker_text_"..obj_id)
	end
end

--старт таймера в реальном времени
--function start_timer(name,delay,action)
function start_timer(name, delay, parameters) counterAdd("amk.start_timer")

	if not delay then return false end
	if not parameters then parameters = "" end

	if not timers then
		timers = load_table("timers")
	end

	table_insert(timers, {timers_name_id[name], math_floor(game_milliseconds() + delay * 1000 * getIniValueFloatSimple("alife","time_factor", 5)), parameters})

	-- сортируем для оптимизации дальнейшего поиска по таймерам
	-- таймеры с меньшим временем будут в конце таблицы
	table_sort(timers, timersSort)
	save_table("timers", timers)
	return true
end

-- функция сравнения для сортировки таймеров
-- в конце таблицы таймеры с самым маленьким временем
function timersSort(t1, t2) counterAdd("amk.timersSort")
	return t1[2] > t2[2]
end

--старт таймера в игровом времени
--function g_start_timer(name,delay_d,delay_h,delay_m,action)
function g_start_timer(name, delay_d, delay_h, delay_m, parameters) counterAdd("amk.g_start_timer")
	if delay_d == nil or delay_h == nil or delay_m == nil then return false end
	if not parameters then parameters = "" end
	if not timers then timers = load_table("timers") end

	table_insert(timers, {timers_name_id[name], math_floor(game_milliseconds() + (delay_d*60*24+delay_h*60+delay_m) * 60 * 1000), parameters})

	-- сортируем для оптимизации дальнейшего поиска по таймерам
	-- таймеры с меньшим временем будут в конце таблицы
	table_sort(timers, timersSort)
	
	save_table("timers", timers)
	return true
end

function has_timer(name) counterAdd("amk.has_timer")
	if not timers then timers = load_table("timers") end
	for i = 1, #timers do
		if timers[i][1] == timers_name_id[name] then return true, timers[i][2], timers[i][3] end
	end
	return false, ""
end

function remove_timer(name) counterAdd("amk.remove_timer")
	if not timers then timers = load_table("timers") end
	for i = #timers, 1, -1 do
		if timers[i][1] == timers_name_id[name] then table_remove(timers, i) end
	end

	-- сортируем для оптимизации дальнейшего поиска по таймерам
	-- таймеры с меньшим временем будут в конце таблицы
	table_sort(timers, timersSort)
	save_table("timers", timers)
end

has_g_timer = has_timer
--[[
function has_g_timer(name)
	return has_timer(name)
end
]]

-- Временное хранилище для переменных удалённых из pstor
local emerg_store
-- Удаляем переменные из pstor. Чтобы не переполнить буфер
function emergency_cleanup() counterAdd("amk.emergency_cleanup")
	emerg_store={}
	if load_variable("zombied",false) then
		emerg_store.zombied=load_table("zombied")
		del_variable("zombied")
	end
	emerg_store.timers = load_table("timers")
	del_variable("timers")
	save_variable("emerg",true)
end

-- Восстанавливаем удалённые переменные
function emergency_restore() counterAdd("amk.emergency_restore")
	if emerg_store.zombied then save_table("zombied", emerg_store.zombied) end
	save_table("timers", emerg_store.timers)
	del_variable("emerg")
end

function convert_timers() counterAdd("amk.convert_timers")
	if not timers then timers = load_table("timers") end
	if load_variable("tmcv2",true) then
		local tmp
		local tmp_s
		local name,delay,params
		local g_milliseconds = game_milliseconds()
		--local time_factor = system_ini():r_float("alife","time_factor")
		local time_factor = getIniValueFloatSimple("alife","time_factor",5)
		local timers_to_unpack = 
		{
			["af_transform"]		= true,
			["af_transform_universal"]	= true,
			["sleep_repbox"]		= true,
			["repbox_cond"]			= true,
			["set_condition"]		= true,
			["healing_enemies"]		= true,
			["timer_drop_obj_varka"]	= true,
			["timer_drop_obj_transform"]	= true,
			["timer_drop_obj_teleport"]	= true,
			["timer_drop_obj_hand_teleporter"] = true 
		}
		for a=1,100,1 do
			-- реальные таймеры
			-- очень старые таймеры
			tmp_s = string_format("x_timer_%s",a)
			tmp=load_variable(tmp_s, nil)
			if tmp ~= nil then
				name = tmp
				delay = load_variable(string_format("%s_delay",tmp_s),0)
				params = load_variable(string_format("%s_params",tmp_s),"")
				-- 400499000 -- поправка на разницу с game.time()
				if timers_to_unpack[name] == true then
					params = unpack_array_from_string(params)
				end
				table_insert(timers, {name, math_floor(delay - 400499000), params})
				del_variable(tmp_s)
				del_variable(string_format("%s_delay",tmp_s))
				del_variable(string_format("%s_params",tmp_s))
			end
			-- старые таймеры
			name = load_variable("xt"..a, nil)
			if name ~= nil then
				delay	= load_variable("xd"..a, nil)
				params	= load_variable("xp"..a, nil)
				-- 400499000 -- поправка на разницу с game.time()
				if timers_to_unpack[name] == true then
					params = unpack_array_from_string(params)
				end
				table_insert(timers, {name, math_floor(delay - 400499000), params})
				del_variable("xt"..a)
				del_variable("xd"..a)
				del_variable("xp"..a)
			end
			-- игровые таймеры
			-- очень старые таймеры
			tmp=load_variable("x_gtimer_"..a,nil)
			if tmp~=nil then
				name,delay,params=tmp,load_variable("x_gtimer_"..a.."_delay",0),load_variable("x_gtimer_"..a.."_params","")
				if timers_to_unpack[name] == true then
					params = unpack_array_from_string(params)
				end
				table_insert(timers, {name, math_floor(delay * 60 * 1000), params})
				del_variable("x_gtimer_"..a)
				del_variable("x_gtimer_"..a.."_delay")
				del_variable("x_gtimer_"..a.."_params")
			end
			-- старые таймеры
			name = load_variable("gt"..a, nil)
			if name ~= nil then
				delay = load_variable("gd"..a, nil)
				params = load_variable("gp"..a, nil)
				if timers_to_unpack[name] == true then
					params = unpack_array_from_string(params)
				end
				table_insert(timers, {name, math_floor(delay * 60 * 1000), params})
				del_variable("gt"..a)
				del_variable("gd"..a)
				del_variable("gp"..a)
			end
		end
		save_variable("tmcv2",false)
		-- сортируем для оптимизации дальнейшего поиска по таймерам
		-- таймеры с меньшим временем будут в конце таблицы
		table_sort(timers, timersSort)
		save_table("timers", timers)
	end
	
	if load_variable("tmcv3",true) then
		-- переводим таймеры с имен на ID
		local timers_new = {}
		for i = 1, #timers do
			if type(timers[i][1]) == "string" then
				table_insert(timers_new, {timers_name_id[timers[i][1]], timers[i][2], timers[i][3]})
			else
				table_insert(timers_new, {timers[i][1], timers[i][2], timers[i][3]})
			end
		end
		timers = timers_new
		
		-- сортируем для оптимизации дальнейшего поиска по таймерам
		-- таймеры с меньшим временем будут в конце таблицы
		table_sort(timers, timersSort)
		save_table("timers", timers)
		save_variable("tmcv3",false)
	end
end

--проверка таймеров
function check_timers() counterAdd("amk.check_timers")
	if not timers then timers = load_table("timers") end
	local id, name -- ID, имя действия
	local delay -- задержка в игровых миллисекундах
	local parameters -- параметры действия
	local timersToStart = {} -- список таймеров на запуск, которые запустятся после очистки таблицы, так как таблица может одновременно чистится и заполнятся в процессе запуска действий
	local milliseconds = game_milliseconds()
	
	for i = #timers, 1, -1 do -- идём с хвоста по таймерам с наименьшим временем срабатывания
		id			= timers[i][1]
		name		= timers_id_name[id]
		delay		= timers[i][2]
		parameters	= timers[i][3]
		--if type(parameters) == "table" then
		--	parameters = pack_array_to_string(parameters)
		--end
		if delay <= milliseconds then
			table_insert(timersToStart, {name, parameters})
			table_remove(timers) -- сначала чистим таблицу, а то ещё в __do_timer_action() она может быть дополнена
		else -- таймеров с временем меньшим за текущее уже нет, так как таблица была отсортирована
			break
		end
	end

	if #timersToStart > 0 then -- какие-то таймеры сработали и были удалены из таблицы
		-- перезаписываем таблицу
		save_table("timers", timers)
	
		-- запуск действий на выполнение
		for i = 1, #timersToStart do
			name		= timersToStart[i][1]
			parameters	= timersToStart[i][2]
			oau_reason = name--.." "..parameters -- для протокола в случае слежки
			__do_timer_action(name, parameters)		
		end
	end
end

-- таблица функций для ускорения их вызовов
-- используется ниже
local func_by_string = {}
	func_by_string["tag_trup_to_zombie"] = function (params_string) counterAdd("amk.tag_trup_to_zombie")
		tag_spb.trup_to_zombie(params_string)
	end
	func_by_string["sidor_trader_repair"] = function (params_string) counterAdd("sidor_trader_repair")
		ui_repair_menu.set_order_ready( params_string, 1 )
	end
	func_by_string["dolgovyazyj_trader_repair"] = function (params_string) counterAdd("amk.dolgovyazyj_trader_repair")
		ui_repair_menu.set_order_ready( params_string, 1 )
	end
	func_by_string["shurup_trader_repair"] = function (params_string) counterAdd("amk.shurup_trader_repair")
		ui_repair_menu.set_order_ready( params_string, 1 )
	end
	func_by_string["vasiliy_trader_repair"] = function (params_string) counterAdd("amk.vasiliy_trader_repair")
		ui_repair_menu.set_order_ready( params_string, 1 )
	end
	func_by_string["petr_trader_repair"] = function (params_string) counterAdd("amk.petr_trader_repair")
		ui_repair_menu.set_order_ready( params_string, 1 )
	end
	func_by_string["jupiter_rem_trader_repair"] = function (params_string) counterAdd("amk.jupiter_rem_trader_repair")
		ui_repair_menu.set_order_ready( params_string, 1 )
	end
	func_by_string["unload_o_weapon"] = function (params_string) counterAdd("amk.unload_o_weapon")
		ui_repair_menu.unload_weapon( params_string )
	end
	func_by_string["sms_new"] = function (params_string) counterAdd("amk.sms_new")
		braad_test.sms_new()
	end
	func_by_string["boroda_sosolov_sms"] = function (params_string) counterAdd("amk.sms_new")
	sol_utils.send_tip( "%c[255,160,160,160]".."БОРОДА:".."\\n".."%c[255,255,128,128]Привет, это Борода. Разведка доложила, что видели этого охотника в районе пионерлагеря.", nil, nil, 30000)
	db.actor:give_info_portion("boroda_say_tri_start")
	end
	func_by_string["sms_new1"] = function (params_string) counterAdd("amk.sms_new1")
		braad_test.sms_new1()
	end
	func_by_string["luis_killself"] = function (params_string) counterAdd("amk.luis_killself")
		braad_test.luis_killself()
	end
	func_by_string["delete_black_doctor"] = function (params_string) counterAdd("amk.delete_black_doctor")
		braad_test.delete_black_doctor()
	end
	func_by_string["show_news"] = function (params_string) counterAdd("amk.show_news")
		amk_mod.show_news()
	end
	func_by_string["gg_need_sleep"] = function (params_string) counterAdd("amk.gg_need_sleep")
		amk_mod.test_for_need_sleep()
	end
	func_by_string["block_sleep_menu"] = function (params_string) counterAdd("amk.block_sleep_menu")
		save_variable("block_sleep_menu",0)
	end
	func_by_string["af_transform"] = function (params_string) counterAdd("amk.af_transform")
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = amk.unpack_array_from_string(params_string)
		end
		amk_mod.af_transform_end(tbl)
	end
	func_by_string["af_transform_universal"] = function (params_string) counterAdd("amk.af_transform_universal")
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = amk.unpack_array_from_string(params_string)
		end
		amk_mod.af_transform_universal_end(tbl)
	end
	func_by_string["amk_freeplay"] = function (params_string) counterAdd("amk.amk_freeplay")
		if amk.load_variable("freeplay",0)==1 and level.name()=="l12_stancia_2" then
			xr_effects.game_credits()
		end
	end
	func_by_string["blowout"] = function (params_string) counterAdd("amk.blowout")
		amk_mod.Blowout_pp(params_string)
	end
	func_by_string["test"] = function (params_string) counterAdd("amk.test")
		amk_mod.Run_Blowout_pp()
	end
	func_by_string["blowout_ss"] = function (params_string) counterAdd("amk.blowout_ss")
		amk_mod.blowout_scary_sounds()
	end
	func_by_string["blow_shift"] = function (params_string) counterAdd("amk.blow_shift")
		amk_mod.Run_Blowout_pp()
	end
	func_by_string["sleep_repbox"] = function (params_string) counterAdd("amk.sleep_repbox")
		amk_mod.repair_weapon(params_string)
	end
	func_by_string["repbox_cond"] = function (params_string) counterAdd("amk.repbox_cond")
		amk_mod.after_repair_weapon(params_string)
	end
	func_by_string["collect_anomalies_info"] = function (params_string) counterAdd("amk.collect_anomalies_info")
		amk_anoms.collect_info()
	end
	func_by_string["news_check"] = function (params_string) counterAdd("amk.news_check")
		if (news_main and news_main.check_news) then news_main.check_news() end
 	end
	func_by_string["set_condition"] = function (params_string) counterAdd("amk.set_condition")
		-- для совместимости оставлен старый способ с распаковкой
		local data
		if type(params_string) == "table" then
			data = params_string
		else
			data = unpack_array_from_string(params_string)
		end
		local a = level.object_by_id(data[1])
		if a then
			a:set_condition(data[2]/100)
			if IAmAOutfit[a:clsid()] then
				bind_stalker.outfit_restored = false
			end
		end
 	end
	func_by_string["set_condition_wpn_spawn"] = function (params_string) counterAdd("amk.set_condition_wpn_spawn")
		-- для совместимости оставлен старый способ с распаковкой
		local data
		if type(params_string) == "table" then
			data = params_string
		else
			data = unpack_array_from_string(params_string)
		end
		bind_wpn.set_condition(data[1])
 	end
	func_by_string["set_patroni"] = function (params_string) counterAdd("amk.set_patroni")
		-- для совместимости оставлен старый способ с распаковкой
		local data
		if type(params_string) == "table" then
			data = params_string
		else
			data = unpack_array_from_string(params_string)
		end
		local a = level.object_by_id(data[1])
		if a then 
			a:set_ammo_elapsed(data[2])
		end
 	end
	func_by_string["healing_enemies"] = function (params_string) counterAdd("amk.healing_enemies")
		-- для совместимости оставлен старый способ с распаковкой
		local arr
		if type(params_string) == "table" then
			arr = params_string
		else
			arr = unpack_array_from_string(params_string)
		end
		local id = arr[1]
		local name = arr[2]
		local comm = arr[3]
		local revers = arr[4]
		local npc = level.object_by_id(id)
		-- если нпс на текущей локации
		if npc then
			return ex_wound_help.auto_change(npc,name,comm,revers)
		end
		-- ГГ успел удрать на другую локу
		ex_wound_help.recovery_params(id,name,comm)
	end
	func_by_string["timer_drop_obj_varka"] = function (params_string) counterAdd("amk.timer_drop_obj_varka")
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end
		
		local sobj = alife():object(tbl.obj_id)
		if sobj == nil then	-- съели
			--amk.send_tip("съели","съели",0,15,"gen_info")
		elseif sobj.parent_id == 65535 then	-- выбросили
			--amk.send_tip("выбросили","выбросили",0,15,"gen_info")
			-- запускаем проверку на рецепт и, если успешно, варку
			local obj	= level.object_by_id(tbl.obj_id)
			local anom	= level.object_by_id(tbl.anom_id)
			if obj and anom then -- если чего само выпадет или будет вброшено в игру скриптом при переходе ГГ между уровнями, то obj == nil и аномалии тоже не будет
				local obj_sect	= obj:section()
				local obj_pos	= obj:position()
				local anom_sect	= anom:section()
				local anom_pos	= anom:position()
				amk_mod.check_af_transform(obj, obj_sect, obj_pos, tbl.anom_id, anom_sect, anom_pos, tbl.anom_radius, tbl.lv, tbl.gv)
			end
		-- else amk.send_tip("переложили","переложили",0,15,"gen_info")
		end
 	end
	func_by_string["timer_drop_obj_transform"] = function (params_string) counterAdd("amk.timer_drop_obj_transform")
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end
		
		local sobj = alife():object(tbl.obj_id)
		if sobj == nil then	-- съели
			--amk.send_tip("obj_id = "..tbl.obj_id.." type: "..type(tbl.obj_id),"съели",0,15,"gen_info")
		elseif sobj.parent_id == 65535 then	-- выбросили
			--amk.send_tip("выбросили","выбросили",0,15,"gen_info")
			-- запускаем трансформацию предмета
			local obj = level.object_by_id(tbl.obj_id)
			if obj then amk_mod.item_transform(tbl)	end
		-- else amk.send_tip("переложили","переложили",0,15,"gen_info")
		end
 	end
	func_by_string["timer_drop_obj_teleport"] = function (params_string) counterAdd("amk.timer_drop_obj_teleport")
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end

		local sobj = alife():object(tbl.obj_id)
		if sobj == nil then	-- съели
			--amk.send_tip("съели","съели",0,15,"gen_info")
			spawn_level_changer.teleport_start(tbl.obj_sect, tbl.obj_id, true)
		elseif sobj.parent_id == 65535 then -- выбросили
			--amk.send_tip("выбросили","выбросили",0,15,"gen_info")
			-- запускаем телепорт
			spawn_level_changer.teleport_start(tbl.obj_sect, tbl.obj_id, false)
		-- else amk.send_tip("переложили","переложили",0,15,"gen_info")
		end
 	end

	func_by_string["autosave"] = function (params_string) counterAdd("amk.autosave")
        u3_utils.savegame(params_string)
    end
	func_by_string["babah_drop_timeBomb"] = function (params_string) counterAdd("amk.babah_drop_timeBomb")
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end
		
		local sobj = alife():object(tbl.id)
		if sobj == nil then	-- съели/использовали
			--amk.send_tip("съели","съели",0,15,"gen_info")
			babah.useTimeBomb(tbl)
		elseif sobj.parent_id == 65535 then	-- выбросили
			--amk.send_tip("выбросили","выбросили",0,15,"gen_info")
			babah.dropTimeBomb(tbl)
		else	-- переложили
			--amk.send_tip("переложили","переложили",0,15,"gen_info")
			babah.relocateTimeBomb(tbl)
		end
 	end
	func_by_string["babah.onItemDropCheck"] = function (id) counterAdd("amk.babah_drop_timeBomb")
		
		local sobj = alife():object(id)
		if sobj == nil then	-- съели/использовали
			amk.send_tip("съели","съели",0,15,"gen_info")
			--babah.useTimeBomb(tbl)
		elseif sobj.parent_id == 65535 then	-- выбросили
			amk.send_tip("выбросили","выбросили",0,15,"gen_info")
			babah.onItemDropCheck(id)
		else	-- переложили
			amk.send_tip("переложили","переложили",0,15,"gen_info")
			--babah.relocateTimeBomb(tbl)
		end
 	end
	func_by_string["babah_timeBomb_activated"] = function (params_string) counterAdd("amk.babah_timeBomb_activated")
		local id = tonumber(params_string)
		babah.explosiveExplode(id)
 	end
	func_by_string["babah_explode_moved_timeBomb"] = function (params_string) counterAdd("amk.babah_explode_moved_timeBomb")
		local id = tonumber(params_string)
		babah.explodeMovedTimeBomb(id)
 	end
	func_by_string["babah_move_timeBomb"] = function (tbl) counterAdd("amk.babah_move_timeBomb")
		babah.moveTimeBomb(tbl)
 	end
	func_by_string["babah_timeBomb_transfer"] = function (params_string) counterAdd("amk.babah_timeBomb_transfer")
		local id = tonumber(params_string)
		babah.transferTimeBomb(id)
 	end
	func_by_string["babah_explode_biside_explosives"] = function (params_string) counterAdd("amk.babah_explode_biside_explosives")
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end
		babah.explodeBisideExplosives(tbl)
 	end
	func_by_string["babah_drop_mine"] = function (params_string) counterAdd("amk.babah_drop_mine")
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end
		local sobj = alife():object(tbl.id)
		if sobj == nil then	-- съели/использовали
			--amk.send_tip("съели","съели",0,15,"gen_info")
		elseif sobj.parent_id == 65535 then	-- выбросили
			--amk.send_tip("выбросили","выбросили",0,15,"gen_info")
			babah.dropMine(tbl)
		-- else amk.send_tip("переложили","переложили",0,15,"gen_info")
		end
 	end

	func_by_string["babah_activateMine"] = function (params_string) counterAdd("amk.babah_activateMine")
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end
		local sobj = alife():object(tbl.id)
		babah.addMine(sobj)
 	end

	func_by_string["babah_drop_detonator"] = function (params_string) counterAdd("amk.babah_drop_detonator")
		-- для совместимости оставлен старый способ с распаковкой
		local tbl
		if type(params_string) == "table" then
			tbl = params_string
		else
			tbl = unpack_array_from_string(params_string)
		end
		local sobj = alife():object(tbl.id)
		if sobj == nil then	-- съели/использовали
			--amk.send_tip("съели","съели",0,15,"gen_info")
			babah.useDetonator(tbl.sect)
		-- elseif sobj.parent_id == 65535 then amk.send_tip("выбросили","выбросили",0,15,"gen_info")
		-- else amk.send_tip("переложили","переложили",0,15,"gen_info")
		end
 	end

	func_by_string["babah_activateDetonator"] = function (params_string) counterAdd("amk.babah_activateDetonator")
		babah.explodeBombsByDetonator(params_string)
 	end

	func_by_string["babah_kamikazze_free"] = function (id) counterAdd("amk.babah_activateDetonator")
		local id = tonumber(id)
		babah.kamikazzeFree(id)
 	end

	func_by_string["amkUseTransmutator"] = function (params_string) counterAdd("amk.amkUseTransmutator")
        local id = tonumber(params_string)
		local sobj = alife():object(id)
		if sobj == nil then	-- съели/использовали
			--amk.send_tip("съели","съели",0,15,"gen_info")
			amk.oAmkLauncher:AddFunc("UseTransmutator", "amkII_transmutator.amkEnableDevice(2)")
		-- elseif sobj.parent_id == 65535 then amk.send_tip("выбросили","выбросили",0,15,"gen_info")
		-- else amk.send_tip("переложили","переложили",0,15,"gen_info")
		end
 	end

	func_by_string["UseTeleport"] = function (params_string) counterAdd("amk.UseTeleport")
        local id = tonumber(params_string)
		local sobj = alife():object(id)
		if sobj == nil then
			amk.oAmkLauncher:AddFunc("UseTeleport", "teleport_menu.EnableDevice(1)")
		-- elseif sobj.parent_id == 65535 then	-- выбросили
		-- else	-- переложили
		end
 	end

	func_by_string["UseAdminBook"] = function (params_string) counterAdd("amk.UseAdminBook")
        local id = tonumber(params_string)
		local sobj = alife():object(id)
		if sobj == nil then
			amk.oAmkLauncher:AddFunc("UseAdminBook", "sysadmin.EnableDevice(1)")
		end
 	end
	
	func_by_string["UseRemnabor"] = function (params_string) counterAdd("amk.UseRemnabor")
        local id = tonumber(params_string)
		local sobj = alife():object(id)
		if sobj == nil then
			amk.oAmkLauncher:AddFunc("UseRemnabor", "sh_remnabor.EnableDevice(1)")
		end
 	end

	func_by_string["RepairEnd"] =  function (params) counterAdd("amk.RepairEnd")
		sh_remnabor.oDevice:r_done(params)
	end

	func_by_string["thirst_change"] = function (params) counterAdd("amk.thirst_change")
		monnoroch_thirst.mon_thirst:thirst_change_slow(params)
 	end

--dc-- А оно здесь надо ?
--	func_by_string["border_exit"] = function (params)
--		xr_detector.hit_actor(params)
--	end

	func_by_string["new_game"] = function (params) counterAdd("amk.new_game")
		--level.remove_complex_effector(params)
		--level.remove_pp_effector(params)
		db.actor:restore_weapon()
		level.enable_input()
		level.show_indicators()
 	end

	func_by_string["check_npc_inventory"] = function (params) counterAdd("amk.check_npc_inventory")
		local sobj = alife():object(tonumber(params))
		if sobj and sobj.parent_id ~= 65535 and sobj.parent_id ~= 0 then
			local sobj_parent = alife():object(sobj.parent_id)
			if sobj_parent and IAmAStalker[sobj_parent:clsid()] and sobj_parent.alive and sobj_parent:alive() then
				inv_npc.set_need_update(sobj_parent.id)
			end
		end
 	end



	func_by_string["release_by_time"] = function (obj_name) counterAdd("amk.release_by_time")
		local obj = obj_name and alife():object(obj_name)
		if obj then
			local gm_obj = level.object_by_id(obj.id)
			if gm_obj then
				set_offline(obj)
			end
			alife():release(obj, true)
		end
	end	

--- ex_all ----------------------------------------------------------------
func_by_string['timer_hoard'] = function (params_string) counterAdd("amk.timer_hoard")
		-- для совместимости оставлен старый способ с распаковкой
		local tabl
		if type(params_string) == "table" then
			tabl = params_string
		else
			tabl = unpack_array_from_string(params_string)
		end
	local obj_id = tonumber(tabl[1])
	local obj_name = tostring(tabl[2])
	local sobj = alife():object(obj_id)
	-- Если нет объекта или это уже другой объект - работаем дальше:
	if not sobj or (sobj:name() ~= obj_name) then
		ex_hoard.hoard_teleport()
	end
end
func_by_string['timer_hoard_restrictor']=function(params_string) counterAdd("amk.timer_hoard_restrictor")
	ex_hoard.point_stack()
end
func_by_string["horror_shift"]=function(params_string) counterAdd("amk.horror_shift")
	ex_horror.run_horror_effect(params_string)
end
func_by_string["horror"]=function(params_string) counterAdd("amk.horror")
	ex_horror.horror_effects(params_string)
end
func_by_string["horror_ss"]=function(params_string) counterAdd("amk.horror_ss")
	ex_horror.horror_scary_sounds(params_string)
end
func_by_string["monstr_ss"]=function(params_string) counterAdd("amk.monstr_ss")
	ex_horror.monstr_scary_sounds(params_string)
end
func_by_string["phantom_init"]=function(params_string) counterAdd("amk.phantom_init")
	ex_horror.init_phantoms(params_string)
end
func_by_string["timer_bolt_pda"]=function(params_string)
	spawn_zombi.bolt_pda_repair()
end
func_by_string["timer_pda_voyak"]=function(params_string)
	spawn_zombi.pda_voyak_repair()
end
--- ex_all -------------------------------------------------------- end ---

--- sol_all ---------------------------------------------------------------
func_by_string['pes_snotvornoe'] = function (params_string)
		-- для совместимости оставлен старый способ с распаковкой
		local tabl
		if type(params_string) == "table" then
			tabl = params_string
		else
			tabl = unpack_array_from_string(params_string)
		end
	local obj_id = tonumber(tabl[1])
	local obj_name = tostring(tabl[2])
	local sobj = alife():object(obj_id)
	-- Если нет объекта или это уже другой объект - работаем дальше:
	if not sobj or (sobj:name() ~= obj_name) then
		sol_item_drop.pes_snotvornoe()
	end
end
func_by_string["resuply_time3"] = function (params_string)
	-- обновление торговли у Сидора.
end
func_by_string["kpk_hide_start"] = function (params_string)
	arhara_dialog.pda_slom_sms1()
end
func_by_string["kpk_hide_show"] = function (params_string)
	arhara_dialog.enabl_karta()
end
--- sol_all ------------------------------------------------------- end ---

--- Kluk&Muxa Aver ---
func_by_string["muha_bazar_sms"]=function(params_string) counterAdd("amk.muha_bazar_sms")
	arhara_dialog.muha_bazar_sms()
end
func_by_string["muha_bazar_sms1"]=function(params_string) counterAdd("amk.muha_bazar_sms1")
	arhara_dialog.muha_bazar_sms1()
end
--- Kluk&Muxa Aver ---

--- Old Village ---
func_by_string["village_pantera_otvet_sms"]=function(params_string) counterAdd("amk.village_pantera_otvet_sms")
	arhara_dialog.village_pantera_otvet_sms()
end
func_by_string["strelok_kluk_vopros1"]=function(params_string) counterAdd("amk.strelok_kluk_vopros1")
	arhara_dialog.strelok_kluk_vopros1()
end
func_by_string["village_kap_pda"]=function(params_string) counterAdd("amk.village_kap_pda")
	arhara_dialog.village_kap_pda()
end
--- Old Village ---

func_by_string["freeman_call_sms"]=function(params_string) counterAdd("amk.freeman_call_sms")
	new_dialog.freeman_call_sms()
end

	func_by_string["enable_attachable_item_by_id"] = function (params_string) counterAdd("amk.enable_attachable_item_by_id")
		-- для совместимости оставлен старый способ с распаковкой
		local data
		if type(params_string) == "table" then
			data = params_string
		else
			data = unpack_array_from_string(params_string)
		end
		local torch = level.object_by_id(data[1])
		if torch then
			torch:enable_attachable_item(true)
		end
 	end
	func_by_string["activate_slot"] = function (params_string) counterAdd("amk.activate_slot")
		-- для совместимости оставлен старый способ с распаковкой
		local data
		if type(params_string) == "table" then
			data = params_string
		else
			data = unpack_array_from_string(params_string)
		end
		local npc = level.object_by_id(data[1])
		local slot = data[2]
		if npc then
			npc:activate_slot(slot)
		end
 	end
	func_by_string["enable_or_delete_attachable_item_for_npc_by_section"] = function (params_string) counterAdd("amk.enable_or_delete_attachable_item_for_npc_by_section")
		-- для совместимости оставлен старый способ с распаковкой
		local data
		if type(params_string) == "table" then
			data = params_string
		else
			data = unpack_array_from_string(params_string)
		end
		local npc = level.object_by_id(data[1])
		local snpc = alife():object(data[1])
		if npc and snpc then
			local torch = npc:object(data[2])
			if torch then
				local storch = alife():object(torch:id())
				if not storch then return end
				
				local lname = level.name()
				local sname = amk.load_variable("level_on_save","")
				
				local delete = not npc:alive() and not snpc.torch_on
				-- при переходе с другой локации фонарики не аттачатся - удалим их
				delete = delete and lname == sname
				-- если есть фонарик-клон и он не включен и хозяин мёртв -- удалить
				if delete then
					npc:drop_item(torch)
					alife():release(storch, true)
				else
					torch:enable_attachable_item(true)
					if npc:alive() then
						torch:enable_attachable_item(false)
					end
				end
			end
		end
 	end
	
	func_by_string["trade_reset"] = function (params_string) counterAdd("amk.trade_reset")
		if bind_stalker.trader then
			trade_manager.trade_reset(bind_stalker.trader)
			amk.spawn_item_in_inv("wpn_knife_trade", bind_stalker.trader)
			amk.spawn_item_in_inv("scientist_suit_white_trade", bind_stalker.trader)
			start_timer("open_trade", 0.01)
		end
 	end
	
	func_by_string["open_trade"] = function (params_string) counterAdd("amk.open_trade")
		if bind_stalker.trader then
			local obj = bind_stalker.trader:object("wpn_knife_trade")
			local sobj = obj and alife():object(obj:id())
			if sobj then
				alife():release(sobj, true)
			end
			local obj = bind_stalker.trader:object("scientist_suit_white_trade")
			local sobj = obj and alife():object(obj:id())
			if sobj then
				alife():release(sobj, true)
			end
		end
	end
	
	func_by_string["trade_update"] = function (params_string) counterAdd("amk.trade_update")
		if bind_stalker.trader then
			bind_stalker.trader:switch_to_talk()
			trade_manager.update(bind_stalker.trader)
			bind_stalker.trader:switch_to_trade()
		end
 	end
	
function __do_timer_action(select_string,params_string) counterAdd("amk.__do_timer_action")
--[[	здесь описываем вызовы, оформялять в виде
	if select_string=="название условия" then <вызов сторонних функций>
		-- можно передавать npc как параметр
	end

	-- user area, переделал в оптимизированный вид
	-- объявляем:
func_by_string["doc_1"] = function (params_string) бла-бла-бла end
-- объявлять выше перед __do_timer_action --^

	-- вызываем:
if func_by_srtring[select_string] then func_by_srtring[select_string](params_string) end
-- сухо и комфортно ]]
	
	if func_by_string[select_string] then
		func_by_string[select_string](params_string)
	end
	
end
--------------------------------------------------------------------------------------------------------------------

--спавним объекты на карту
--для спавна неписей смотрим config\creatures\spawn_sections.ltx - там написаны имена секций для разных типов неписей
function spawn_item(spawn_item, pos, gv,lv) counterAdd("amk.spawn_item")
	if gv == nil then gv = db.actor:game_vertex_id() end
	if lv == nil then lv = db.actor:level_vertex_id() end
	return alife():create(spawn_item, pos, lv, gv)
end

--для спавна патронов используем spawn_ammo_in_inv
function spawn_item_in_inv(spawn_item,npc) counterAdd("amk.spawn_item_in_inv")
	if npc==nil then npc=db.actor end
	return alife():create(spawn_item, npc:position(), npc:level_vertex_id(),
			npc:game_vertex_id(), npc:id())
end

--используем для спавна патронов
function spawn_ammo_in_inv(spawn_item,number,npc) counterAdd("amk.spawn_ammo_in_inv")
	if npc==nil then npc=db.actor end
	if number > 0 then return se_respawn.create_ammo(spawn_item, npc:position(),
		npc:level_vertex_id(), npc:game_vertex_id(), npc:id(), number)
	end
end

-- удаляем объект из игры
function remove_item(remove_item) counterAdd("amk.remove_item")
	local sim = alife()
	if sim then
		local id = remove_item and remove_item:id()
		local obj = id and sim:object(id)
		if obj then
			sim:release(obj, true)
			return true
		end
	end
	return false
end

-- выбрасываем объект из инвентаря, применимо к ГГ
function drop_item(npc,item) counterAdd("amk.drop_item")
	if item then npc:drop_item(item) end
end

--убиваем непися
function make_suicide(npc) counterAdd("amk.make_suicide")
	npc:kill(npc)
end

--узнаем отношение одного непися к другому
function get_npc_relation(obj, target) counterAdd("amk.get_npc_relation")
	local rel = obj:relation(target)
	local relation
	if rel == game_object.neutral then return "neutral"
	elseif rel == game_object.friend then return "friend"
	elseif rel == game_object.enemy then return "enemy"
	end
	return false
end

--задаем отношение одного непися к другому
function set_npc_relation(obj, target, relation) counterAdd("amk.set_npc_relation")
	local rel
	if relation == "neutral" then rel = game_object.neutral
	elseif relation == "friend" then rel = game_object.friend
	elseif relation == "enemy" then rel=game_object.enemy
	else return false
	end 
	sol_utils.setRelation(obj, rel, target)
	return true
end

-- узнаем группировку непися, применимо к ГГ, только ОНЛАЙН
function get_npc_community(npc) counterAdd("amk.get_npc_community")
	return npc:character_community()
end

--удаляем предмет из инвентаря по имени
function remove_item_from_inventory_by_name(remove_item_name,npc) counterAdd("amk.remove_item_from_inventory_by_name")
	return remove_item_from_inventory(npc:object(remove_item_name),npc)
end

--удаляем предмет из инвентаря
function remove_item_from_inventory(remove_item,npc) counterAdd("amk.remove_item_from_inventory")
	local sim = alife()
	if sim then
		local id = remove_item and remove_item:id()
		local obj = id and sim:object(id)
		if obj then
			sim:release(obj, true)
			return true
		end
	end
	return false
end

--очищаем инвентарь непися, можно ГГ, использует следующую фунцию для удаления предмета
function clear_npc_inventory(npc) counterAdd("amk.clear_npc_inventory")
	npc:iterate_inventory(__del_item, npc)
end
function __del_item(npc, item) counterAdd("amk.__del_item")
	local section = item:section()
	if section == "bolt" or section == "device_torch" or section == "device_torch_clon" then return false end
	remove_item_from_inventory(item, npc)
end
---------------------------

--проверка запущена ли игра
function check_game() counterAdd("amk.check_game")
	if level.present() and db.actor and db.actor:alive() then return true end
	return false
end

-- таблица компрессии имён
local compress_table = {}
local checked=false

-- Преобразует имя переменной в короткое
function compress_name(name) counterAdd("amk.compress_name")
	return name
end

--записываем переменную
function save_variable(variable_name, value) counterAdd("amk.save_variable")
	if value == nil then del_variable(variable_name)
	else xr_logic.pstor_store(db.actor, variable_name, value)
	--	local vn = compress_name(variable_name)
	--	xr_logic.pstor_store(db.actor, vn, value)
	end
end

--загружаем переменную
function load_variable(variable_name, value_if_not_found) counterAdd("amk.load_variable")
	-- local vn=compress_name(variable_name)
	return xr_logic.pstor_retrieve(db.actor, variable_name, value_if_not_found)
end

--удаляем переменную
function del_variable(variable_name) counterAdd("amk.del_variable")
	-- local vn = compress_name(variable_name)
	npc_id = xr_logic.get_pda_id(variable_name,"удаляем")
	if db.storage[npc_id].pstor[variable_name] ~= nil then
		db.storage[npc_id].pstor[variable_name] = nil
	end
end


--определяем находится ли ГГ в определенной зоне
function check_npc_in_box(npc, p1,p2,p3) counterAdd("amk.check_npc_in_box")
	local pos
	if npc.name then pos=npc:position() else pos = npc end
	if p3 == nil then
		if is_point_inside_interval(pos.x,p1.x,p2.x)
		  and is_point_inside_interval(pos.y,p1.y,p2.y)
		  and is_point_inside_interval(pos.z,p1.z,p2.z) then
			return true
		else return false
		end
	else
		local v1,v2,r,proj1,proj2,dv1,dv2
		v1, v2 = sub(p2,p1), sub(p3,p2)
		v1.y, v2.y = 0, 0
		dv1 = v1:magnitude()
		dv2 = v2:magnitude()
		v1:normalize() 
		v2:normalize()
		r = sub(pos,p1)
		local v1p = vector():set(v1.z,0,-v1.x)
		proj2 = v1p:dotproduct(r)/v1p:dotproduct(v2)
		proj1 = v1:dotproduct(r)-v1:dotproduct(v2)*proj2
		if proj1 > 0 and proj1 < dv1 and proj2 > 0 and proj2 < dv2
		  and pos.y > p1.y and pos.y < p3.y then
			return true
		else return false
		end
	end
end

function is_point_inside_interval(x,p1,p2) counterAdd("amk.is_point_inside_interval")
	if p1 > p2 then p1, p2 = p2, p1 end
	if x > p1 and x < p2 then return true
	else return false
	end
end

function sub(v1,v2) counterAdd("amk.sub")
	local newvec = vector()
	newvec.x = v1.x-v2.x
	newvec.y = v1.y-v2.y
	newvec.z = v1.z-v2.z
	return newvec
end
----------------------------

--инвентарное название объекта
function get_inv_name(section) counterAdd("amk.get_inv_name")
	-- return system_ini():r_string(section,"inv_name")
	return getIniValueStringSimple(section,"inv_name","")
end

-- Внимание! Строки в структуре не должны содержать символов с кодами 0-31.
function pack_array_to_string(array) counterAdd("amk.pack_array_to_string")
	return string_format("\001%s", pack_new(array))
end


local pack_type_num=1
local pack_type_string=2
local pack_type_bool=3
local pack_type_table=4
local pack_val_endtable=5

function pack_new(tbl) counterAdd("amk.pack_new")
	local ret = ""
	for k,v in pairs(tbl) do
		local ty = type(k)
		if ty == "number" then ret = string_format("%s\001%s", ret, k)
		elseif ty == "string" then ret = string_format("%s\002%s", ret, k)
		end
		ty = type(v)
		if ty == "number" then ret = string_format("%s\001%s", ret, v)
		elseif ty == "string" then ret = string_format("%s\002%s", ret, v)
		elseif ty == "boolean" then
			if v then ret = string_format("%s\0031", ret)
			else ret = string_format("%s\0030", ret)
			end
		elseif ty == "table" then ret = string_format("%s\004%s\005", ret, pack_new(v))
		end
	end
	return ret
end

function parse_new(str, idx) counterAdd("amk.parse_new")
	local ret={}
	local idx = idx or 1
	local strlen = string_len(str)
	local key, value, vtype, idx1 --, v
	while idx <= strlen do
		vtype, idx = string_byte(string_sub(str, idx, idx)), idx + 1
		if vtype == pack_type_num then
			idx1 = idx
			while idx1 <= strlen do
				if string_byte(string_sub(str, idx1, idx1)) < 32 then break end
				idx1 = idx1 + 1
			end
			key, idx = string_sub(str, idx, idx1 - 1) + 0, idx1
		elseif vtype == pack_type_string then
			idx1 = idx
			while idx1 <= strlen do
				if string_byte(string_sub(str, idx1, idx1)) < 32 then break end
				idx1 = idx1 + 1
			end
			key, idx = string_sub(str, idx, idx1 - 1), idx1
		elseif vtype == pack_val_endtable then
			return ret, idx
		end

		vtype, idx = string_byte(string_sub(str, idx, idx)), idx + 1
		if vtype == pack_type_num then
			idx1 = idx
			while idx1 <= strlen do
				if string_byte(string_sub(str, idx1, idx1)) < 32 then break end
				idx1 = idx1 + 1
			end
			value, idx = string_sub(str, idx, idx1 - 1) + 0, idx1
		elseif vtype == pack_type_string then
			idx1 = idx
			while idx1 <= strlen do
				if string_byte(string_sub(str, idx1, idx1)) < 32 then break end
				idx1 = idx1 + 1
			end
			value, idx = string_sub(str, idx, idx1 - 1), idx1
		elseif vtype == pack_type_bool then
			value = string_sub(str,idx,idx) == "1"
			idx = idx + 1
		elseif vtype == pack_type_table then
			value, idx = parse_new(str,idx)
		end
		ret[key]=value
	end
	return ret, idx
end

function get_byte(str, idx) counterAdd("amk.get_byte")
	return string_byte(string_sub(str, idx, idx)), idx + 1
end

function get_string(str,idx) counterAdd("amk.get_string")
	local idx1 = string_len(str) + 1
	for i = idx, string_len(str), 1 do
		if string_byte(string_sub(str,i,i)) < 32 then
			idx1 = i
			break
		end
	end
	return string_sub(str, idx, idx1 -1 ), idx1
end

function get_num(str,idx) counterAdd("amk.get_num")
	local st, idx1 = get_string(str, idx)
	return st + 0, idx1
end

function get_bool(str,idx) counterAdd("amk.get_bool")
	local st, idx1 = get_string(str, idx)
	return st == "1", idx1
end

function unpack_array_from_string(str) counterAdd("amk.unpack_array_from_string")
	if str ~= "" then
		if string_sub(str,1,1)~=string_char(1) then return _parse(str)	-- Старый формат упаковки
		else
			return parse_new(string_sub(str,2,-1))	-- новый формат упаковки тэгирован символом c кодом 1.
		end
	end
	return {}
end

--[[local unpack_array_from_string_cached = {}
function unpack_array_from_string(str) counterAdd("amk.unpack_array_from_string")
	if str ~= "" then
		if unpack_array_from_string_cached[str] == nil then
			if string_sub(str,1,1)~=string_char(1) then
				unpack_array_from_string_cached[str] = _parse(str)	-- Старый формат упаковки
			else
				unpack_array_from_string_cached[str] = parse_new(string_sub(str,2,-1))	-- новый формат упаковки тэгирован символом c кодом 1.
			end
		end
		return table_copy(unpack_array_from_string_cached[str])
	end
	return {}
end]]


function _assign(tbl,key,val) counterAdd("amk._assign")
	local key0 = string_match(key,'"(.*)"')
	if key0 then tbl[key0] = val
	else tbl[key+0] = val
	end
end


function _parse(str) counterAdd("amk._parse")
	local ret={}
	local str_dc = (str and string_sub(str,1,100)) or "nil" --dc--
	while (str and str ~= "") do
		local i1, i2, key = string_find(str,'(.-)=>')
		str = string_sub(str,i2+1)
		i1, i2, val = string_find(str,'"(.-)"|')
		if val and i1 == 1 then _assign(ret,key,val)	-- строка
		else
			i1, i2, val = string_find(str,'(%b{})|')
			if val and i1 == 1 then	-- таблица
				_assign(ret,key,_parse(string_sub(val,2,-2),"_parse"))
			else
				i1, i2, val  = string_find(str,'(.-)|')	-- число или булево значение
				if val=="true" then _assign(ret,key,true)
				elseif val=="false" then _assign(ret,key,false)
				else _assign(ret,key,val+0)
		end	end	end
		str=string_sub(str,i2+1)
	end
	return ret
end
---------------------------------------------
--callback section
---------------------------------------------

--колбэк на взятие предмета в инвентарь ГГ
function on_item_take(obj) counterAdd("amk.on_item_take")
	if obj and obj:section() == "device_torch_clon" then
		local sobj = alife():object(obj:id())
		if sobj then
			alife():release(sobj, true)
		end
	end
	gps_habar.on_item_take(obj) -- Idler ++--
--	escape_dialog.have_a_art()
	flamethrower.have_a_fire_kolobok()
	flamethrower.have_a_trubki()
	flamethrower.have_a_manometr()
	flamethrower.have_a_vodko()
	flamethrower.have_a_gorelka()
	remove_spot_from_map(obj:id(),"red_location")
	amk_mod.check_usable_item(obj)
end

--колбэк на потерю предмета из инвентаря ГГ
function on_item_drop(obj) counterAdd("amk.on_item_drop")
gps_habar.on_item_drop(obj) --idler++--
	amk_mod.check_for_af_drop(obj)
	amk_mod.check_for_item_drop(obj)
	amk_mod.check_beacon_drop(obj)
	amk_alcohol.drink_vodka(obj)	--!!! alcohol modification by Terrapack
	amkII_transmutator.amkUseTransmutator(obj)
	teleport_menu.UseTeleport(obj)
	sysadmin.UseAdminBook(obj)
	sh_remnabor.UseRemnabor(obj)
	flamethrower.have_a_fire_kolobok()
	flamethrower.have_a_trubki()
	flamethrower.have_a_manometr()
	flamethrower.have_a_vodko()
	flamethrower.have_a_gorelka()
	babah.onItemDrop(obj)
end

function on_actor_update_2()
 if amk_target then amk_target.update() end 

 local sim = alife()
 local t, n = {}, 0
 for k, v in pairs( convert_npc ) do
  if v == 2 then -- фикс от несработавшего апдейта
   v = sim:story_object( k )
   if v then sim:set_switch_online( v.id, true ) end
   n = n + 1; t[n] = k
  elseif sim:object( k ) then -- иначе все действо теряет смысл
   if v == 1 then -- Надо запихнуть в офлайн, чтобы сохранилось содержимое
    if level.object_by_id( k ) then -- онлайне, сохраняем
     sim:set_switch_online( k, false )
     sim:set_switch_offline( k, true )
    else -- уже в офлайне, разрешаем выйти
     sim:set_switch_online( k, true )
     n = n + 1; t[n] = k
    end
   elseif v == true then -- пожизненный онлайн
    sim:set_switch_online( k, true )
    sim:set_switch_offline( k, false )
    n = n + 1; t[n] = k
   elseif v == false then n = n + 1; t[n] = k 
   end
  else n = n + 1; t[n] = k
  end
 end
 for i = 1, n do convert_npc[t[n]] = nil end
end

local prev_health=0
--колбэк на апдейт ГГ (удобно для проверки условий, так как вызывается постоянно, нельзя перегружать, а то будут лаги)
function on_actor_update() counterAdd("amk.on_actor_update")
	oau_watchdog=100
	local sim = alife()
	local actor = db.actor
	local milliseconds = game_milliseconds()
	--не удалять! библиотечная конструкция
	if not timer_trigger then timer_trigger = milliseconds end
	if timer_trigger <= milliseconds then
		timer_trigger = milliseconds + 250
		check_timers()
	end
	-- user area

	oau_watchdog=90
	if game_options.gg_kick then	
		if prev_health > actor.health + 0.1 then
			level.add_pp_effector("amk_shoot.ppe", 2011, false)
			level.set_pp_effector_factor(2011, (prev_health-actor.health)*100)  
			if prev_health > actor.health + 0.2 then
				local cameffs, sounds
				if prev_health > actor.health + 0.5 then
					cameffs = {"head_shot","fusker"}
					sounds = {"pain_4","pain_1","hit_5","hit_6"}
				else
					cameffs ={"shell_shock","hit_front","hit_right","hit_back","hit_left","hit_front_left","hit_back_left","hit_front_right","hit_back_right"}
					sounds = {"pain_2","pain_3","pain_5","pain_6","pain_7","pain_8"}
				end
				level.add_cam_effector("camera_effects\\"..cameffs[math_random(#cameffs)]..".anm", 999, false, "")
				local snd_obj = xr_sound.get_safe_sound_object("actor\\"..sounds[math_random(#sounds)])
				snd_obj:play_no_feedback(actor, sound_object.s2d, 0, vector(), 1.0)
				xr_effects.actor_drop_active_item()
		end	end
		prev_health = actor.health
	end
	oau_watchdog=89
	if (amk_corpses) then for a=1, 3 do amk_corpses.update() end
	end
	oau_watchdog=86
	oAmkLauncher:UpdateFuncs()

	oau_watchdog=0
	oau_reason=""
end

function set_offline(sobj) counterAdd("amk.set_offline")
	local id = sobj and sobj.id
	local obj = id and level.object_by_id(id)
	if obj and npc_by_clsid[sobj:clsid()] then
		if obj:alive() then
			if not IAmAMonster[sobj:clsid()] then
				obj:stop_talk()
			end
		end
		obj:clear_animations()
	end
	switch_offline(obj)
end

function release(obj_guess) counterAdd("amk.release")	-- удаление неписей
	local sobj = ((type(obj_guess) == "string") and alife():object(obj_guess)) or ((type(obj_guess) == "number") and alife():story_object(obj_guess))
	if sobj then
		set_offline(sobj)
		if npc_by_clsid[sobj:clsid()] then
			local strn_id = sobj.smart_terrain_id and sobj:smart_terrain_id()
			local strn = strn_id and strn_id ~= 65535 and alife():object(strn_id)
			if strn then
				strn:unregister_npc(sobj)
			end
			amk.start_timer("release_by_time", 1, sobj:name())
		else
			alife():release(sobj,true)
		end
		return true
	end
	return false
end

-----------------------

--колбэк на удаление непися (точнее на его переход в оффлайн), использует следующую за ним функцию для выбора действия
function on_npc_go_offline(npc) counterAdd("amk.on_npc_go_offline")
	amk_anoms.unreg_in_anom_manager(npc)
	if amk_target then amk_target.net_destroy(npc) end

--dc-- в потолке открылся люк - не пугайтесь, это глюк.
--	if amk_offline_alife then
--		if check_game()==true then
--			local sobj = alife():object(npc:id())
--			if sobj then amk_offline_alife.process_trade(sobj) end
--	end	end
end

function on_monster_go_offline(npc) counterAdd("amk.on_monster_go_offline")
--	amk_anoms.unreg_in_anom_manager(npc)
	if amk_target then amk_target.net_destroy(npc) end
end
-----------------------

--колбэк на юзание объекта
function on_use(victim, who) counterAdd("amk.on_use")
	if db.actor and who and who:id()==db.actor:id() then
		amk_mod.check_usable_item(victim)
	end
end

--колбэк на смерть непися
function on_death(victim, who) counterAdd("amk.on_death")
	if (news_main and news_main.on_death) then
		news_main.on_death(victim, who)
	end
	amk_anoms.unreg_in_anom_manager(victim)
	--amk_mod.generate_recipe(victim,who)
	amk_mod.firebated(victim, 1, nil, who, 14)
	amk_mod.zomby_blow(victim)
	--amk_mod.rat_tnt(victim) 
	
	--[=[if IAmAStalker[victim:clsid()]
		and victim:character_community() ~= "zombied"
		and who:id() == db.actor:id()
		and (--[[xr_wounded.is_wounded(victim) or]] victim:relation(who) == game_object.neutral or victim:relation(who) == game_object.friend)
		and victim:profile_name() ~= "ecolog_wound_bunker"
	then
		local k = victim:relation(who) == game_object.neutral and 1 or 2 -- за друга - в двое больше
		local difficulty = level.get_game_difficulty()
		who:change_character_reputation(math_floor(-(5+5*difficulty)*k))
		
		-- ухудшаем отношение тех, кто видел содеянное
		local obj
		for npcId, npc in pairs(db.storage) do
			obj = level.object_by_id(npcId)
			if obj and IAmAStalker[obj:clsid()] and npcId ~= who:id() and obj:alive() and obj:see(who) then
				-- особый случай - нельзя переводить на sol_utils
				obj:change_goodwill(math_floor(-(5+5*difficulty)*k), who)
			end
		end
		
		if k == 1 then
			relation_registry.change_community_goodwill(victim:character_community(), who:id(), math_floor(-(5+5*difficulty)))
		else
			-- ухудшаем отношение дружественных группировок в целом
			local comm = {"stalker", "monolith", "military", "killer", "ecolog", "dolg", "freedom", "bandit", "nebo", "lastday", "bandos", "voin", "green", "sniper"}
			for i = 1, #comm do
				if utils2.community_relation(comm[i], who) > 1000 then
					-- особый случай - нельзя переводить на sol_utils
					relation_registry.change_community_goodwill(comm[i], who:id(), math_floor(-(5+5*difficulty)*k))
				end
			end
		end
	end]=]
	
	if babah then
		babah.onDeath(victim, who)
	end

end

function on_npc_hit(obj, amount, local_direction, who, bone_index) counterAdd("amk.on_npc_hit")
	amk_mod.firebated(obj, amount, local_direction, who, bone_index)
	if game_options.interative_music and db.actor and who and who:id()==db.actor:id() and amount>0 then
		amk_mod.calc_adrenaline("actor_hit_enemy",obj,"npc")
	end
	
	if babah then
		babah.onHit(obj, amount, local_direction, who, bone_index)
	end
end

function on_monster_hit(obj, amount, local_direction, who, bone_index) counterAdd("amk.on_monster_hit")
	amk_mod.firebated(obj, amount, local_direction, who, bone_index)
	if game_options.interative_music and db.actor and who and who:id()==db.actor:id() and amount>0 then
		amk_mod.calc_adrenaline("actor_hit_enemy",obj,"monster")
	end
	
	if babah then
		babah.onHit(obj, amount, local_direction, who, bone_index)
	end

end

-- проверка на видимость производится раз в секунду
function enemy_see_actor(obj,typ) counterAdd("amk.enemy_see_actor")
	local onj_n10 = string_sub(obj:name(), 1, 10)
	if obj_n10 == "ferma_band" and not has_alife_info("sveeblov_ferma_have") then
		db.actor:give_info_portion("sveeblov_ferma_fail")
	end
	if game_options.interative_music then amk_mod.calc_adrenaline("enemy_see_actor", obj, typ) end
end

function actor_see_enemy(obj,typ) counterAdd("amk.actor_see_enemy")
	if game_options.interative_music then amk_mod.calc_adrenaline("actor_see_enemy", obj, typ) end
end

-- непись стрелял в гг
function npc_shot_actor(obj) counterAdd("amk.npc_shot_actor")
	if game_options.interative_music then amk_mod.calc_adrenaline("enemy_hit_actor", obj, "npc") end
end

--загружаем все переменные, которые нужно, вызывается загрузке игры, автоматически; вручную не вызывать
function on_game_load() counterAdd("amk.on_game_load")
	-- готовим таймеры к работе с id вместо названий
	local i = 1
	for k,v in pairs(func_by_string) do
		table_insert(timers_id_name, k)
		timers_name_id[k] = i
		i = i + 1
	end

	if db.storage[db.actor:id()].pstor == nil then db.storage[db.actor:id()].pstor = {} end

	-- для совместимости оставлен старый способ с распаковкой
	local x_npc_spawner = load_variable("x_npc_spawner", "")
	if type(x_npc_spawner) == "table" then
		npc_spawner = x_npc_spawner
	else
		npc_spawner = unpack_array_from_string(x_npc_spawner)
	end

	game_options.new_game = amk.load_variable("x_first_run",true)
	amk_mod.first_run()
	convert_timers() -- переносим старые и новые таймеры в таблицу
	-- Метки теперь ставятся на серверные объекты. Обновлять их не нужно

	--user area 
	amk_mod.test_sleep_pp()
	amk_mod.check_spawn()
end

--записываем все переменные, которые нужно, вызывается присохранении игры, автоматически; вручную не вызывать
function on_game_save() counterAdd("amk.on_game_save")
end

-- Эта функция вызывается самой первой. Онлайновые объекты недоступны! db.actor недоступен!
function on_game_start() counterAdd("amk.on_game_start")
	getStartTime()
	treasure_manager:get_treasure_manager()
end

function getStartTime() counterAdd("amk.getStartTime")
	local strTime = getIniValueStringSimple("alife", "start_time")
	local t = Parse_StrToTbl(strTime, ":")
	local d = Parse_StrToTbl(getIniValueStringSimple("alife", "start_date"), ".")
	StartTime = game.CTime()
	StartTime:set(d[3], d[2], 1, 0, 0, 0, 0)
	local temp = game.CTime()
	temp:setHMS(24,0,0)
	StartTime = StartTime - temp
end

--------------------- user function section---------------
function mod_call(i,...) counterAdd("amk.mod_call")
	amk_mod[i](...)
end

function load_table(name) counterAdd("amk.load_table")
	local var = load_variable(name)
	if type(var) == "table" then
		return var
	elseif var then
		return unpack_array_from_string(var) end
	return {}
end

function save_table(name,tbl) counterAdd("amk.save_table")
	save_variable(name, tbl)
end

function update_table(name,id,val) counterAdd("amk.update_table")
	local tbl = load_table(name)
	tbl[id] = val
	save_table(name, tbl)
	return tbl
end

function bind_lc(obj) counterAdd("amk.bind_lc")
end

function dump_table(tbl, lvl, tbl_name) counterAdd("amk.dump_table")
	if not lvl or lvl < 1 then lvl = 1 end
	if tbl_name then get_console():execute(string_format("load ~~~ dump_table '%s':", tbl_name)) end
	if type(tbl) ~= "table" then
		get_console():execute("load ~~~ is not table. This is "..type(tbl))
		return
	end
	for k,v in pairs(tbl) do
		if type(v) == "table" then
			get_console():execute(string_format("load ~~~ %s%s (%s) => (%s)", string_rep(".",lvl),(type(k) == "string" or type(k) == "number" or type(k) == "boolean" or type(k) == "string" or type(k) == "nil" or type(k) == "function") and tostring(k) or "~"..type(k).."~",type(k),type(v)))
			dump_table(v,lvl + 1)
		elseif type(v) == "string" or type(v) == "number" or type(v) == "boolean" or type(v) == "function" then
			str = string_format("load ~~~ %s%s (%s) => %s (%s)", string_rep(".", lvl), (type(k) == "string" or type(k) == "number" or type(k) == "boolean" or type(k) == "string" or type(k) == "nil" or type(k) == "function") and tostring(k) or "~"..type(k).."~", type(k), (type(k) == "string" and "\"" or "")..tostring(v)..(type(k) == "string" and "\"" or ""), type(v))
			if string_len(str)>200 then str=string_sub(str,1,200) end
			get_console():execute(str)
		elseif type(v) == "userdata" then
			get_console():execute(string_format("load ~~~ %s%s => (%s)", string_rep(".",lvl),"~~~",type(v)))
		else	
			get_console():execute(string_format("load ~~~ %s%s (%s) => (%s)", string_rep(".",lvl),"~~~","неизвестно",type(v)))
		end
	end
end

function parse_ini_section_to_array(ini,section) counterAdd("amk.parse_ini_section_to_array")
	local tmp={}
	if ini:section_exist(section) then
		local result, id, value = nil, nil, nil
		for a=0,ini:line_count(section)-1 do
			result, id, value = ini:r_line(section,a,"","")
			if id~=nil and trim(id)~="" and trim(id)~=nil then
				tmp[trim(id)]=trim(value)
			end
		end
	end
	return tmp
end

local parse_ini_section_to_array_cached = {}
function parse_ini_section_to_array_new(iniFileName, section) counterAdd("amk.parse_ini_section_to_array_new")
	local tmp={}
	
	local iniName = iniFileName or "system_ini"
	if parse_ini_section_to_array_cached[iniName] and parse_ini_section_to_array_cached[iniName][section] then
		return table_copy(parse_ini_section_to_array_cached[iniName][section])
	end
	
	if parse_ini_section_to_array_cached[iniName] == nil then
		parse_ini_section_to_array_cached[iniName] = {}
	end
	
	if iniFileName then
		local ini = g_ini_file(iniFileName)
		if ini:section_exist(section) then
			local result, id, value = nil, nil, nil
			for a=0,ini:line_count(section)-1 do
				result, id, value = ini:r_line(section,a,"","")
				if id~=nil and trim(id)~="" and trim(id)~=nil then
					tmp[trim(id)]=trim(value)
				end
			end
		end
	else -- system_ini
		if iniSectionExistSimple(section) then
			local result, id, value = nil, nil, nil
			for a=0,iniLinesCountSimple(section)-1 do
				result, id, value = getIniLineSimple(section,a,"","")
				if id~=nil and trim(id)~="" and trim(id)~=nil then
					tmp[trim(id)]=trim(value)
				end
			end
		end
	end
	
	parse_ini_section_to_array_cached[iniName][section] = tmp
	
	return table_copy(tmp)
end

local game_milliseconds_cached, game_seconds_cached
local game_time_ms
function game_milliseconds() counterAdd("amk.game_milliseconds")
	local gt = game.time()
	if game_time_ms ~= gt then
		game_time_ms = gt
		if StartTime == nil then
			getStartTime()
			if StartTime == nil then return 0, 0 end
		end
		local gtime = game.get_game_time()
		game_seconds_cached = gtime:diffSec(StartTime)
		local y,m,d,h,min,sec,ms = gtime:get()
		game_milliseconds_cached = game_seconds_cached * 1000 + ms
	end
	return game_milliseconds_cached, game_seconds_cached
end

function game_seconds() counterAdd("amk.game_seconds")
	local ms, s = game_milliseconds()
	return s
end

function game_minutes() counterAdd("amk.game_minutes")
	return math_floor(game_seconds() / 60)
end

function game_hours() counterAdd("amk.game_hours")
	return math_floor(game_seconds() / 3600)
end

function game_days() counterAdd("amk.game_days")
	return math_floor(game_seconds() / 86400)
end
