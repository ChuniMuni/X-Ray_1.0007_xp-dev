----------------------------------------------------------------------------------------------------
-- Physic objects binding
----------------------------------------------------------------------------------------------------
-- Разработчик: Evgeniy Negrobov (Jon) jon@gsc-game.kiev.ua
-- Доработки: Andrey Fidrya (Zmey) af@svitonline.com
----------------------------------------------------------------------------------------------------

function init( obj )
	local ini = obj:spawn_ini()
	if ini and ( ini:section_exist( "drop_box" ) or ini:section_exist( "logic" ) )
	  or not ini and obj:clsid() == clsid.projector then
		db.storage[obj:id()] = {}
		local new_binder = generic_physics_binder( obj )
		obj:bind_object( new_binder )
	end
end


class "generic_physics_binder" (object_binder)

function generic_physics_binder:__init(obj) super(obj)
	self.initialized = false
	self.loaded = false
end 

function generic_physics_binder:reload(section)
	object_binder.reload(self,section)
end

function generic_physics_binder:reinit()
	object_binder.reinit(self)
	db.storage[self.object:id()] = {}
	self.st = db.storage[self.object:id()]
	self.health = self.object:get_car() and self.object:get_car():GetfHealth()
end

function generic_physics_binder:update(delta)
	object_binder.update(self,delta)
	if not self.initialized and db.actor then
		self.initialized = true
		xr_logic.initialize_obj(self.object,self.st,self.loaded,db.actor,modules.stype_item)
		--' Запускаем ассоциированный с объектом партикл.
		local particle = utils.cfg_get_string(self.st.ini,self.st.section_logic,"particle",self.object,false,"",nil)
		if particle then
			self.particle = particles_object(particle)
			self.particle:play_at_pos(self.object:position())
		end
		--' Дизаблим ассоциированный с объектом граф
		local graph_point_marker = utils.cfg_get_string(self.st.ini,self.st.section_logic,"graph_point_marker",self.object,false,"",nil)
		if graph_point_marker then
			self.disable_graph_point = patrol(graph_point_marker):game_vertex_id(0)
			game_graph():accessible(self.disable_graph_point,false)
		end
	end
	if self.st.active_section or (self.object:spawn_ini() and self.object:spawn_ini():section_exist("drop_box")) then
		xr_logic.issue_event(self.object,self.st[self.st.active_scheme],"update",delta)
--		if not self.callbackset then
			self.object:set_callback(callback.hit, generic_physics_binder.hit_callback, self)
			self.object:set_callback(callback.death, generic_physics_binder.death_callback, self)
			self.object:set_callback(callback.use_object, generic_physics_binder.use_callback, self)
--			self.callbackset = true
--		end
		-- для бтра hit_callback не вызывается. заткнём эту дырку.
		if self.health and (not self.nofixonhit) then
			local health = self.object:get_car() and self.object:get_car():GetfHealth()
			if health then
				if self.health - health > 0.00001 then
					self.health = health
					self:hit_callback(self.object,self.health - health,vector():set(1,0,0),db.actor,0)
					self.nofixonhit = nil
				end
			end
		end
	else
--		self.callbackset = false
	end
end


function generic_physics_binder:net_spawn( data )
	if not object_binder.net_spawn( self, data ) then
		return false
	end
	local obj = self.object
	local cls = obj:clsid()
	if cls == clsid.projector then
		db.add_sl(self.object)
	elseif cls == clsid.car_s then
		local h = hit()
		h.power = 0
		h.impulse = 0.0001
		h.draftsman = obj
		h.direction = vector():set(0,0,0)
		h.type = hit.strike
		obj:hit(h)
	end
	return true
end


function generic_physics_binder:net_destroy()
	local st = db.storage[self.object:id()]
	if st.active_scheme then
		xr_logic.issue_event(self.object,st[st.active_scheme],"net_destroy")
	end
	if self.particle then
		self.particle:stop()
	end
	if self.object:clsid() == clsid.projector then
		db.del_sl(self.object)
	end
	db.storage[self.object:id()] = nil
	object_binder.net_destroy(self)
end

function generic_physics_binder:net_save_relevant()
	return true
end

function generic_physics_binder:save(packet)
	object_binder.save(self,packet)
	xr_logic.save_obj(self.object,packet)
end

function generic_physics_binder:load(reader)
	self.loaded = true
	object_binder.load(self,reader)
	xr_logic.load_obj(self.object,reader)
end

function generic_physics_binder:use_callback(victim,who)
	local depot = self.st
	if depot.active_section then
		xr_logic.issue_event(self.object,depot[depot.active_scheme],"use_callback",victim,who)
	end
end

function generic_physics_binder:hit_callback(victim,amount,local_direction,who,bone_index)
	local depot = self.st
	if depot.ph_on_hit then
		xr_logic.issue_event(self.object,depot.ph_on_hit,"hit_callback",victim,amount,local_direction,who,bone_index)
	end
	if depot.active_section then
		xr_logic.issue_event(self.object,depot[depot.active_scheme],"hit_callback",victim,amount,local_direction,who,bone_index)
	end
	self.nofixonhit = true
end

function generic_physics_binder:death_callback(victim,who)
	local depot = self.st
	local ini = self.object:spawn_ini()
	if depot.active_section then
		xr_logic.issue_event(self.object,depot[depot.active_scheme],"death_callback",victim,who)
	end
	if self.particle then
		self.particle:stop()
	end
	if self.disable_graph_point then
		game_graph():accessible(self.disable_graph_point,true)
	end
	if ini and ini:section_exist("drop_box") then xr_box.spawn_items( self.object ) end
end